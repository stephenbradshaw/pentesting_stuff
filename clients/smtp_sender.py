#!/usr/bin/env python
'''SMTP sender'''
from __future__ import print_function
from builtins import bytes
from optparse import OptionParser
from email.mime.base import MIMEBase
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from email import utils
import smtplib
import os
import sys
import mimetypes
import socket
import select
import random



# shut up about constants pylint!
# pylint: disable-msg=C0103

def rnumeric(length):
    '''Generate a numeric string of given length'''
    return ''.join([str(random.randint(0, 9)) for a in range(0, length)])


def msg_id():
    '''Generate a message id'''
    return '.'.join([rnumeric(a) for a in [12, 4, 20]]) + '@' + socket.gethostname()


def detect_filetype(fn, bodyFile=False):
    '''Detect mime type information about a file'''
    ct, enc = mimetypes.guess_type(fn)
    if ct is None and bodyFile:
        fdata = open(fn, 'rb').read()
        ct = 'text/html' if '<html>' in fdata else 'text/plain'
    else:
        if ct is None or enc is not None:
            ct = 'application/octet-stream'
    return ct.split('/', 1) # [maintype, subtype]


def sendraw(address, sendr, recip, subj, afrom=None, nheaders=None, bheaders=None, textbody=None, data=None, debug=False):
    '''Send a raw email using a socket'''
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect(address)
    s.setblocking(0)

    send_heads = [
        'mail FROM:<%s>\n' %(sendr),
        'rcpt TO:<%s>\n' %(recip),
        'data\n'
    ]

    if not afrom:
        afrom = sendr

    if nheaders:
        end = send_heads.pop()
        send_heads += [a + '\n' for a in nheaders]
        send_heads += [end]

    # if the data value is provided, it will need to be completely specified
    # otherwise it is built here from a template
    if not data:
        if not textbody:
            raise Exception('Need to provide textbody')
        if bheaders:
            dat2 = '\n'.join(bheaders) + '\n'
        else:
            dat2 = ''

        boundary = rnumeric(19)
        dat1 = ('Content-Type: multipart/mixed; boundary="===============%s=="\n'
                'MIME-Version: 1.0\n'
                'Message-ID: <%s>\n') %(boundary, msg_id())

        dat3 = ('Subject: %s\n'
                'from: %s\n'
                'To: %s\n'
                '\n'
                '%s\n'
                '--===============%s==\n'
                '\n'
                '--===============%s==--\n'
               ) %(subj, afrom, recip, textbody, boundary, boundary)
        data = dat1 + dat2 + dat3

    check_receive = True
    sent_main = False

    while check_receive:
        ready = select.select([s], [], [], 5)
        if ready[0]:
            received = s.recv(4096)

            if debug:
                print('R: ' + received)

            if received.startswith(b'220'):
                val = b'ehlo [127.0.0.1]\n'
                s.send(val)
                if debug:
                    print('S: ' + val)
            elif received.startswith(b'250 OK') or b'250 HELP' in received or received.startswith(b'500'):
                if send_heads:
                    val = bytes(send_heads.pop(0), 'ascii')
                    s.send(val)
                    if debug:
                        print('S: ' + val)
                elif sent_main:
                    val = b'quit\n'
                    s.send(val)
                    if debug:
                        print('S: ' + val)
                    check_receive = False
                    ready = select.select([s], [], [], 5)
                    if ready[0]:
                        received = s.recv(4096)
                        if debug:
                            print('R: ' + received)

            elif received.startswith(b'354'):
                val = bytes(data + '\r\n.\r\n', 'ascii')
                s.send(val)
                if debug:
                    print('S: ' + val)
                sent_main = True
            elif received.startswith(b'250'):
                if debug:
                    print('R: ' + received)
            else:
                raise Exception('Unexpected response from server: ' + received)

    s.close()


if __name__ == '__main__':
    parser = OptionParser(usage='%prog [options]')
    parser.add_option('-d', '--debug', dest='debug',
                      action='store_true', help='show debugging messages')
    parser.add_option('-s', '--subject', dest='subject', help='email subject [required]')
    parser.add_option('-f', '--from', dest='sender', help='email from address [required]')
    parser.add_option('-b', '--body', dest='body', help='email body')
    parser.add_option('-t', '--bodyfile', dest='bodyfile', help='email body from file')
    parser.add_option('-z', '--host', dest='host', help='SMTP host [required]')
    parser.add_option('-p', '--port', dest='port', type='int', help='SMTP port [required]')
    #parser.add_option('-e', '--base64', dest='b64', action='store_true',
    #                  help='Base64 encoding (default)')
    parser.add_option('-g', '--afrom', dest='asender', help='email body from')
    parser.add_option('-o', '--bodyencode', dest='bodyencode',
                      action='store_true', help='Use selected encoder to encode body content')
    parser.add_option('-r', '--recipients',
                      dest='recipients',
                      help='comma separated list of email recipients [required]')
    parser.add_option('-a', '--attachments',
                      dest='attachments',
                      help='comma separated list of email attachments')
    parser.add_option('-j', '--smtpheaders',
                      dest='smtpheaders',
                      help='comma separated list of smtp headers')
    parser.add_option('-k', '--bodyheaders',
                      dest='bodyheaders',
                      help='comma separated list of body headers')
    parser.add_option('-i', '--binary', dest='binary',
                      help='Dont detect attachment filetype, send binary')
    parser.add_option('-w', '--raw', dest='raw', action='store_true',
                      help='Send the SMTP message using a raw socket to allow greater manipulation')             
    opts, args = parser.parse_args()

    if not opts.sender or not opts.subject:
        print('Required options missing - you must specify values for -f/--from and /s/--subject')
        sys.exit(1)

    try:
        recipients = opts.recipients.replace(' ', '').split(',')
        subject = opts.subject
        sender = opts.sender
        to = ', '.join(recipients)

        host = opts.host
        port = int(opts.port)

    except (ValueError, NameError, IndexError, AttributeError, TypeError):
        print('Required options missing')
        print(parser.format_help())
        sys.exit(1)

    if opts.asender:
        alt_sender = opts.asender
    else:
        alt_sender = None

    if opts.bodyfile:
        if os.path.exists(opts.bodyfile):
            fd = open(opts.bodyfile, 'rb').read()
            body=None
        else:
            print('Provided body file does not exist')
            sys.exit(1)
    elif opts.body:
        fd = None
        body = opts.body
    else:
            print('Provide either body text or body file')
            print(parser.format_help())
            sys.exit(1)

    if opts.bodyheaders:
        bodyheaders = opts.bodyheaders.replace(', ', ',').split(',')
        if opts.bodyfile:
            print('Cannot specify both bodyfile and bodyheaders options')
            sys.exit(1)
        if not opts.raw:
            print('Bodyheaders option requires raw option to be enabled')
            sys.exit(1)
    else:
        bodyheaders = None

    if opts.smtpheaders:
        smtpheaders = opts.smtpheaders.replace(', ', ',').split(',')
        if not opts.raw:
            print('Smtpheaders option requires raw option to be enabled')
            sys.exit(1)
    else:
        smtpheaders = None


    if opts.raw:
        sendraw((host, int(port)), sender, ','.join(recipients), subject, nheaders=smtpheaders, bheaders=bodyheaders, textbody=body, afrom=alt_sender, data=fd, debug=opts.debug)
    else:

        msg = MIMEMultipart()
        msg['Message-ID'] = utils.make_msgid()
        msg['Subject'] = subject
        msg['from'] = sender
        msg['To'] = sender


        # giving myself the option to add other encoders later on if desired
        encoder = lambda x: x.encode('base64')
        encoder.__doc__ = 'base64'

        #charset = 'UTF-8'
        charset = 'us-ascii'

        if fd: # bodyfile
            maintype, subtype = detect_filetype(opts.bodyfile)
            needEncode = False
            try:
                tdata = fd.encode('ascii')
            except:
                needEncode = True
            if opts.bodyencode or needEncode:
                body = MIMEBase(maintype, subtype, charset=charset)
                body.set_payload(encoder(fd))
                body.add_header('Content-Transfer-Encoding', encoder.__doc__)
            else:
                body = MIMEText(tdata, _subtype=subtype, _charset=charset)
            msg.attach(body)
        elif opts.body:
            if opts.bodyencode:
                dd = 'text/html' if '<html>' in opts.body else 'text/plain'
                maintype, subtype = dd.split('/', 1)
                body = MIMEBase(maintype, subtype, charset=charset)
                body.set_payload(encoder(opts.body))
                body.add_header('Content-Transfer-Encoding', encoder.__doc__)
                msg.attach(body)
            else:
                msg.preamble = opts.body



        if opts.attachments:
            # check for option to not detect filetype
            for filename in opts.attachments.replace(' ', '').split(','):
                attachment = MIMEBase('application', 'octet-stream', charset=charset)
                attachment.set_payload(open(filename, 'rb').read())
                attachment.add_header('Content-Transfer-Encoding', encoder.__doc__)
                #encoders.encode_base64(attachment)
                base_filename = filename.split(os.path.sep)[-1]
                attachment.add_header('Content-Disposition', 'attachment', filename=base_filename)
                msg.attach(attachment)


        smtpi = smtplib.SMTP(host, port)
        smtpi.sendmail(opts.sender, recipients, msg.as_string())
        smtpi.quit()
