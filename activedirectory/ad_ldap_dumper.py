#!/usr/bin/env python
import sys 
import argparse
import ldap3
import ssl
import json
from binascii import hexlify
from ldap3 import Server, Connection, ALL, Tls
from impacket.ldap.ldaptypes import ACE, ACCESS_ALLOWED_OBJECT_ACE, ACCESS_MASK, LDAP_SID, SR_SECURITY_DESCRIPTOR
from datetime import datetime, timedelta
from impacket.uuid import bin_to_string


# TODO: Reproduce Bloodhound format - seperate convertor? Copy the python version or the AD extract tool from that author?
# TODO: Rate limiting for LDAP queries to bypass query volume based detection
# TODO: Add kerberos support, the following method may work
#https://gist.github.com/sigmaris/f4bf307e97b449148d78

#https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-adts/1522b774-6464-41a3-87a5-1e5633c3fbbb
# https://docs.microsoft.com/en-au/windows/win32/adschema/classes-all?redirectedfrom=MSDN
OBJECT_TYPES = {
    'ee914b82-0a98-11d1-adbb-00c04fd8d5cd': 'Abandon-Replication',
    '440820ad-65b4-11d1-a3da-0000f875ae0d': 'Add-GUID',
    '1abd7cf8-0a99-11d1-adbb-00c04fd8d5cd': 'Allocate-Rids',
    '68b1d179-0d15-4d4f-ab71-46152e79a7bc': 'Allowed-To-Authenticate',
    'edacfd8f-ffb3-11d1-b41d-00a0c968f939': 'Apply-Group-Policy',
    '0e10c968-78fb-11d2-90d4-00c04f79dc55': 'Certificate-Enrollment',
    'a05b8cc2-17bc-4802-a710-e7c15ab866a2': 'Certificate-AutoEnrollment',
    '014bf69c-7b3b-11d1-85f6-08002be74fab': 'Change-Domain-Master',
    'cc17b1fb-33d9-11d2-97d4-00c04fd8d5cd': 'Change-Infrastructure-Master',
    'bae50096-4752-11d1-9052-00c04fc2d4cf': 'Change-PDC',
    'd58d5f36-0a98-11d1-adbb-00c04fd8d5cd': 'Change-Rid-Master',
    'e12b56b6-0a95-11d1-adbb-00c04fd8d5cd': 'Change-Schema-Master',
    'e2a36dc9-ae17-47c3-b58b-be34c55ba633': 'Create-Inbound-Forest-Trust',
    'fec364e0-0a98-11d1-adbb-00c04fd8d5cd': 'Do-Garbage-Collection',
    'ab721a52-1e2f-11d0-9819-00aa0040529b': 'Domain-Administer-Server',
    '69ae6200-7f46-11d2-b9ad-00c04f79f805': 'DS-Check-Stale-Phantoms',
    '2f16c4a5-b98e-432c-952a-cb388ba33f2e': 'DS-Execute-Intentions-Script',
    '9923a32a-3607-11d2-b9be-0000f87a36b2': 'DS-Install-Replica',
    '4ecc03fe-ffc0-4947-b630-eb672a8a9dbc': 'DS-Query-Self-Quota',
    '1131f6aa-9c07-11d1-f79f-00c04fc2dcd2': 'DS-Replication-Get-Changes',
    '1131f6ad-9c07-11d1-f79f-00c04fc2dcd2': 'DS-Replication-Get-Changes-All',
    '89e95b76-444d-4c62-991a-0facbeda640c': 'DS-Replication-Get-Changes-In-Filtered-Set',
    '1131f6ac-9c07-11d1-f79f-00c04fc2dcd2': 'DS-Replication-Manage-Topology',
    'f98340fb-7c5b-4cdb-a00b-2ebdfa115a96': 'DS-Replication-Monitor-Topology',
    '1131f6ab-9c07-11d1-f79f-00c04fc2dcd2': 'DS-Replication-Synchronize',
    '05c74c5e-4deb-43b4-bd9f-86664c2a7fd5': 'Enable-Per-User-Reversibly-Encrypted-Password',
    'b7b1b3de-ab09-4242-9e30-9980e5d322f7': 'Generate-RSoP-Logging',
    'b7b1b3dd-ab09-4242-9e30-9980e5d322f7': 'Generate-RSoP-Planning',
    '7c0e2a7c-a419-48e4-a995-10180aad54dd': 'Manage-Optional-Features',
    'ba33815a-4f93-4c76-87f3-57574bff8109': 'Migrate-SID-History',
    'b4e60130-df3f-11d1-9c86-006008764d0e': 'msmq-Open-Connector',
    '06bd3201-df3e-11d1-9c86-006008764d0e': 'msmq-Peek',
    '4b6e08c3-df3c-11d1-9c86-006008764d0e': 'msmq-Peek-computer-Journal',
    '4b6e08c1-df3c-11d1-9c86-006008764d0e': 'msmq-Peek-Dead-Letter',
    '06bd3200-df3e-11d1-9c86-006008764d0e': 'msmq-Receive',
    '4b6e08c2-df3c-11d1-9c86-006008764d0e': 'msmq-Receive-computer-Journal',
    '4b6e08c0-df3c-11d1-9c86-006008764d0e': 'msmq-Receive-Dead-Letter',
    '06bd3203-df3e-11d1-9c86-006008764d0e': 'msmq-Receive-journal',
    '06bd3202-df3e-11d1-9c86-006008764d0e': 'msmq-Send',
    'a1990816-4298-11d1-ade2-00c04fd8d5cd': 'Open-Address-Book',
    '1131f6ae-9c07-11d1-f79f-00c04fc2dcd2': 'Read-Only-Replication-Secret-Synchronization',
    '45ec5156-db7e-47bb-b53f-dbeb2d03c40f': 'Reanimate-Tombstones',
    '0bc1554e-0a99-11d1-adbb-00c04fd8d5cd': 'Recalculate-Hierarchy',
    '62dd28a8-7f46-11d2-b9ad-00c04f79f805': 'Recalculate-Security-Inheritance',
    'ab721a56-1e2f-11d0-9819-00aa0040529b': 'Receive-As',
    '9432c620-033c-4db7-8b58-14ef6d0bf477': 'Refresh-Group-Cache',
    '1a60ea8d-58a6-4b20-bcdc-fb71eb8a9ff8': 'Reload-SSL-Certificate',
    '7726b9d5-a4b4-4288-a6b2-dce952e80a7f': 'Run-Protect_Admin_Groups-Task',
    '91d67418-0135-4acc-8d79-c08e857cfbec': 'SAM-Enumerate-Entire-Domain',
    'ab721a54-1e2f-11d0-9819-00aa0040529b': 'Send-As',
    'ab721a55-1e2f-11d0-9819-00aa0040529b': 'Send-To',
    'ccc2dc7d-a6ad-4a7a-8846-c04e3cc53501': 'Unexpire-Password',
    '280f369c-67c7-438e-ae98-1d46f3c6f541': 'Update-Password-Not-Required-Bit',
    'be2bb760-7f46-11d2-b9ad-00c04f79f805': 'Update-Schema-Cache',
    'ab721a53-1e2f-11d0-9819-00aa0040529b': 'User-Change-Password',
    '00299570-246d-11d0-a768-00aa006e0529': 'User-Force-Change-Password',
    '3e0f7e18-2c7a-4c10-ba82-4d926db99a3e': 'DS-Clone-Domain-Controller',
    '084c93a2-620d-4879-a836-f0ae47de0e89': 'DS-Read-Partition-Secrets',
    '94825a8d-b171-4116-8146-1e34d8f54401': 'DS-Write-Partition-Secrets',
    '4125c71f-7fac-4ff0-bcb7-f09a41325286': 'DS-Set-Owner',
    '88a9933e-e5c8-4f2a-9dd7-2527416b8092': 'DS-Bypass-Quota',
    '9b026da6-0d3c-465c-8bee-5199d7165cba': 'DS-Validated-Write-Computer',
    'e362ed86-b728-0842-b27d-2dea7a9df218': 'ms-DS-ManagedPassword',
    '037088f8-0ae1-11d2-b422-00a0c968f939': 'rASInformation',
    '3e0abfd0-126a-11d0-a060-00aa006c33ed': 'sAMAccountName',
    '3f78c3e5-f79a-46bd-a0b8-9d18116ddc79': 'msDS-AllowedToActOnBehalfOfOtherIdentity',
    '46a9b11d-60ae-405a-b7e8-ff8a58d456d2': 'tokenGroupsGlobalAndUniversal',
    '47cf3000-0019-4754-8c71-da7b9a2d5349': '47cf3000-0019-4754-8c71-da7b9a2d5349', # could not find
    '4828cc14-1437-45bc-9b07-ad6f015e5f28': 'inetOrgPerson',
    '4c164200-20c0-11d0-a768-00aa006e0529': 'userAccountRestrictions',
    '5805bc62-bdc9-4428-a5e2-856a0f4c185e': 'terminalServerLicenseServer',
    '59ba2f42-79a2-11d0-9020-00c04fc2d3cf': 'generalInformation',
    '5b47d60f-6090-40b2-9f37-2a4de88f3063': 'msDS-KeyCredentialLink',
    '5f202010-79a5-11d0-9020-00c04fc2d4cf': 'logonInformation',
    '6db69a1c-9422-11d1-aebd-0000f80367c1': 'terminalServer',
    '72e39547-7b18-11d1-adef-00c04fd8d5cd': 'validatedDNSHostName',
    '736e4812-af31-11d2-b7df-00805f48caeb': 'trustedDomain',
    '77b5b886-944a-11d1-aebd-0000f80367c1': 'personalInformation',
    '91e647de-d96f-4b70-9557-d63ff4f3ccd8': 'privateInformation',
    'b7c69e6d-2cc7-11d2-854e-00a0c983f608': 'tokenGroups',
    'b8119fd0-04f6-4762-ab7a-4986c76b3f9a': 'domainOtherParameters',
    'bc0ac240-79a9-11d0-9020-00c04fc2d4cf': 'groupMembership',
    'bf967950-0de6-11d0-a285-00aa003049e2': 'description',
    'bf967953-0de6-11d0-a285-00aa003049e2': 'displayName',
    'bf967a7f-0de6-11d0-a285-00aa003049e2': 'userCertificate',
    'bf967a86-0de6-11d0-a285-00aa003049e2': 'computer',
    'bf967a9c-0de6-11d0-a285-00aa003049e2': 'organizationalUnit',
    'bf967aa8-0de6-11d0-a285-00aa003049e2': 'printer',
    'bf967aba-0de6-11d0-a285-00aa003049e2': 'user',
    'c47d1819-529b-4c8a-8516-4f273a07e43c': 'c47d1819-529b-4c8a-8516-4f273a07e43c', # could not find
    'c7407360-20bf-11d0-a768-00aa006e0529': 'domainPassword',
    'e45795b2-9455-11d1-aebd-0000f80367c1': 'emailInformation',
    'e45795b3-9455-11d1-aebd-0000f80367c1': 'webInformation',
    'e48d0154-bcf8-11d1-8702-00c04fb96050': 'publicInformation',
    'ea1b7b93-5e48-46d5-bc6c-4df4fda78a35': 'msTPM-TpmInformationForComputer',
    'f3a64788-5306-11d1-a9c5-0000f80367c1': 'servicePrincipalName',
    'bf967aa5-0de6-11d0-a285-00aa003049e2': 'organizationalUnit',
    'bf967a9c-0de6-11d0-a285-00aa003049e2': 'group',
    '5cb41ed0-0e4c-11d0-a286-00aa003049e2': 'contact',
    '19195a5a-6da0-11d0-afd3-00c04fd930c9': 'domain',
    'f30e3bc2-9ff0-11d1-b603-0000f80367c1': 'groupPolicyContainer'
}


LOOKUPS = {
    #https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-adts/5026a939-44ba-47b2-99cf-386a9e674b04
    'trustDirection' : {0 : 'DISABLED', 1: 'INBOUND', 2: 'OUTBOUND', 3: 'BIDIRECTIONAL'},
    
    #https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-adts/36565693-b5e4-4f37-b0a8-c1b12138e18e
    'trustType' : {1 : 'DOWNLEVEL', 2: 'UPLEVEL', 3: 'MIT', 4: 'DCE'}
}


FLAGS = {

    #https://docs.microsoft.com/en-us/troubleshoot/windows-server/identity/useraccountcontrol-manipulate-account-properties
    'userAccountControl' : 
    {
        'SCRIPT'            : 0x0001,
        'ACCOUNTDISABLE'    : 0x0002,
        'HOMEDIR_REQUIRED'  : 0x0008,
        'LOCKOUT'           : 0x0010,
        'PASSWD_NOTREQD'    : 0x0020,
        'PASSWD_CANT_CHANGE': 0x0040,
        'ENCRYPTED_TEXT_PWD_ALLOWED' : 	0x0080,
        'TEMP_DUPLICATE_ACCOUNT' : 	0x0100,
        'NORMAL_ACCOUNT' : 	0x0200,
        'INTERDOMAIN_TRUST_ACCOUNT' : 0x0800,
        'WORKSTATION_TRUST_ACCOUNT' : 0x1000,
        'SERVER_TRUST_ACCOUNT' : 0x2000,
        'DONT_EXPIRE_PASSWORD' : 0x10000,
        'MNS_LOGON_ACCOUNT' : 0x20000,
        'SMARTCARD_REQUIRED' : 0x40000,
        'TRUSTED_FOR_DELEGATION' : 0x80000,
        'NOT_DELEGATED'	: 0x100000,
        'USE_DES_KEY_ONLY' : 0x200000,
        'DONT_REQ_PREAUTH': 0x400000,
        'PASSWORD_EXPIRED' : 0x800000,
        'TRUSTED_TO_AUTH_FOR_DELEGATION' :0x1000000,
        'PARTIAL_SECRETS_ACCOUNT': 0x04000000,
    },

    #https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-adts/e9a2d23c-c31e-4a6f-88a0-6646fdb51a3c
    'trustAttributes' :
    {
        'NON_TRANSITIVE':0x00000001,
        'UPLEVEL_ONLY':0x00000002,
        'QUARANTINED_DOMAIN':0x00000004,
        'FOREST_TRANSITIVE':0x00000008,
        'CROSS_ORGANIZATION':0x00000010,
        'WITHIN_FOREST':0x00000020,
        'TREAT_AS_EXTERNAL':0x00000040,
        'USES_RC4_ENCRYPTION':0x00000080,
        'CROSS_ORGANIZATION_NO_TGT_DELEGATION':0x00000200,
        'CROSS_ORGANIZATION_ENABLE_TGT_DELEGATION': 0x00000800,
        'PIM_TRUST':0x00000400
    }
}


class AdDumper:

    def __init__(self, host, username=None, password=None, ssl=False, sslprotocol=None, port=None):
        self.host = host
        if not username:
            self.authentication = None
        elif '\\' in username:
            self.authentication = 'NTLM'
        else:
            self.authentication = 'SIMPLE'
        self.username = username 
        self.password = password 
        self.ssl = ssl 
        self.port = port if port else 636 if self.ssl else 389
        spv = self.get_supported_tls()
        if sslprotocol:
            if sslprotocol in spv:
                self.sslprotocol = spv[sslprotocol]
            else:
                raise Exception('Bad SSL Protocol value provided, choose one from: {}'.format(', '.join(list(spv))))
        

        self.post_process_data = True
        self.multi_field = ['dSCorePropagationData', 'objectClass']
        self.datetime_format = '%Y-%m-%d %H:%M:%S.%f %Z %z'
        self.timestamp = False
        self.paged_size = 500
        # LDAP_SERVER_SD_FLAGS_OID - 0x07 flag value, queries for all values in nTSecurityDescriptor apart from SACL
        self.controls = [('1.2.840.113556.1.4.801', True, "\x30\x03\x02\x01\x07")] 
        
        self.domainLT = None
        self.domainLTNB = None
        self.convert_binary = True

        self.ace_flags = self.get_ace_flag_constants()
        self.access_masks = self.get_access_mask_constants()

        # start with well known SIDS https://docs.microsoft.com/en-us/windows/win32/secauthz/well-known-sids
        self.sidLT = {
            'S-1-0-0' : 'Null',
            'S-1-1-0' : 'World',
            'S-1-2-0' : 'Local',
            'S-1-3-0' : 'Creator Owner',
            'S-1-3-1' : 'Creator Group',
            'S-1-5-1' : 'DIALUP',
            'S-1-5-2' : 'NETWORK',
            'S-1-5-3' : 'BATCH',
            'S-1-5-4' : 'INTERACTIVE',
            'S-1-5-5' : 'LOGON_IDS',
            'S-1-5-6' : 'SERVICE',
            'S-1-5-7' : 'ANONYMOUS',
            'S-1-5-8' : 'PROXY',
            'S-1-5-9' : 'ENTERPRISE_CONTROLLERS',
            'S-1-5-10' : 'PRINCIPAL_SELF',
            'S-1-5-11' : 'AUTHENTICATED_USER',
            'S-1-5-13' : 'TERMINAL_SERVICES',
            'S-1-5-13' : 'TERMINAL_SERVER',
            'S-1-5-18' : 'LOCAL_SYSTEM',
            'S-1-5-21' : 'NT_NON_UNIQUE',
            'S-1-5-32' : 'BUILTIN_DOMAIN',
            'S-1-5-33' : 'WRITE_RESTRICTED_CODE',
            'S-1-5-32-544' : 'Administrators'

        }

        
        #self.connect()


    
    def get_ace_flag_constants(self):
        return {a:ACE.__dict__[a] for a in ACE.__dict__ if a == a.upper()}


    def get_access_mask_constants(self):
        access_mask = {a:ACCESS_MASK.__dict__[a] for a in ACCESS_MASK.__dict__ if a == a.upper() }
        access_mask.update({a:ACCESS_ALLOWED_OBJECT_ACE.__dict__[a] for a in ACCESS_ALLOWED_OBJECT_ACE.__dict__ if a.startswith('ADS_')})
        return access_mask

        

    def get_supported_tls(self):
        try:
            return {a.name:a.value for a in ssl.TLSVersion if 'SUPPORTED' not in a.name}
        except:
            return {'SSLv23' : 2, 'TLSv1' : 3, 'TLSv1_1' : 4, 'TLSv1_2' : 5}

    def connect(self):
        if self.ssl:
            if self.sslprotocol:
                Server(self.host, get_info=ALL, port=self.port, use_ssl=True, tls=Tls(validate=0, version=self.sslprotocol) )
            else:
                self.server = Server(self.host, get_info=ALL, port=self.port, use_ssl=True)
        else:
            self.server = Server(self.host, get_info=ALL, port=self.port)
        
        self.connection = Connection(self.server, user=self.username, password=self.password, authentication=self.authentication)


        bindresult = self.connection.bind()
        if not bindresult:
            raise Exception('An error occurred when attempting to bind to the LDAP server: {}'.format(', '.join(['{} : {}' .format(a, self.connection.result[a]) for a in  self.connection.result])))
        self.root = self.server.info.other['defaultNamingContext'][0]
    

    def parseSecurityDescriptor(self, nTSecurityDescriptor):
        out = {}
        sd = SR_SECURITY_DESCRIPTOR()
        sd.fromString(nTSecurityDescriptor)
        if sd['OwnerSid']:
            out['OwnerSid'] = sd['OwnerSid'].formatCanonical()
            if out['OwnerSid'] in self.sidLT:
                out['OwnerName'] = self.sidLT[out['OwnerSid']]
        if sd['GroupSid']:
            out['GroupSid'] = sd['GroupSid'].formatCanonical()
            if out['GroupSid'] in self.sidLT:
                out['GroupName'] = self.sidLT[out['GroupSid']]
        if sd['Dacl']:
            out['Dacls'] = []
            for ace in sd['Dacl']['Data']:
                dacl = {'Type' : ace['TypeName']}
                dacl['Sid'] = ace['Ace']['Sid'].formatCanonical()
                if dacl['Sid'] in self.sidLT:
                    d = [self.sidLT[dacl['Sid']]]
                    domainsid = self.get_domain_sid(dacl['Sid'])
                    if domainsid in self.domainLTNB:
                        d.append(self.domainLTNB[domainsid])
                    elif dacl['Sid'].startswith('S-1-5-32-'):
                        d.append('Builtin')
                    dacl['ResolvedSidName'] = '\\'.join(d[::-1])
                    dacl['Foreign'] = False
                elif dacl['Sid'].count('-') > 6:
                    dacl['Foreign'] = True

                dacl['Flags'] = []
                for flag in self.ace_flags:
                    if ace.hasFlag(self.ace_flags[flag]):
                        dacl['Flags'].append(flag)
                dacl['Privs'] = []
                for priv in self.access_masks:
                    if ace['Ace']['Mask'].hasPriv(self.access_masks[priv]):
                        dacl['Privs'].append(priv)

                if 'ObjectType' in ace['Ace'].fields and len(ace['Ace']['ObjectType']) > 0:
                    type_guid = bin_to_string(ace['Ace']['ObjectType']).lower()
                    if type_guid in OBJECT_TYPES:
                        dacl['ControlObjectType'] = OBJECT_TYPES[type_guid]
                    else:
                        dacl['ControlObjectType'] = type_guid
                if 'InheritedObjectType' in ace['Ace'].fields and len(ace['Ace']['InheritedObjectType']) > 0:
                    type_guid = bin_to_string(ace['Ace']['InheritedObjectType']).lower()
                    if type_guid in OBJECT_TYPES:
                        dacl['InheritableObjectType'] = OBJECT_TYPES[type_guid]
                    else:
                        dacl['InheritableObjectType'] = type_guid
                out['Dacls'].append(dacl)

        return out

    def parse_records(self, records):
        out = []
        for record in records:
            orecord = record.entry_attributes_as_dict
            for key in orecord:
                for index in range(0, len(orecord[key])):
                    if isinstance(orecord[key][index], datetime):
                        if self.timestamp:
                            orecord[key][index] = orecord[key][index].timestamp()
                        else:
                            orecord[key][index] = orecord[key][index].strftime(self.datetime_format)
                    elif isinstance(orecord[key][index], timedelta):
                        orecord[key][index] = str(orecord[key][index])
                if len(orecord[key]) == 1 and key not in self.multi_field:
                    orecord[key] = orecord[key][0]

            for entry in FLAGS:
                if entry in orecord:
                    orecord['{}Flags'.format(entry)] = [a for a in FLAGS[entry] if self.hasFlag(FLAGS[entry][a], orecord[entry])]

            for entry in LOOKUPS:
                if entry in orecord:
                    orecord['{}Resolved'.format(entry)] = LOOKUPS[entry][orecord[entry]]
                        
            out.append(orecord)
        return out

    def update_sidlt(self, data):
        self.sidLT.update({a['objectSid']: a['sAMAccountName'] for a in data if 'objectSid' in a and 'sAMAccountName' in a})

    def get_domain_sid(self, sid):
        return '-'.join(sid.split('-')[:-1])


    def jsonify(self, data, delistify=False):
        if isinstance(data, list) or isinstance(data, tuple):
            if delistify:
                if len(data) == 1:
                    return self.jsonify(data[0])
            return [self.jsonify(a) for a in data]
        elif isinstance(data, dict):
            for key in data:
                data[key] = self.jsonify(data[key])
        elif isinstance(data, bytes):
            try:
                data = data.decode('utf-8')
                return data 
            except:
                pass
            return hexlify(data).decode('utf-8')
        elif isinstance(data, str):
            if data.isdigit():
                return int(data)
            if data.lower() == 'true':
                return bool('1')
            elif data.lower() == 'false':
                return bool('')
        return data


    def query_computers(self):
        self.connection.extend.standard.paged_search(self.root, '(&(objectClass=computer)(objectClass=user))', controls=self.controls, attributes=ldap3.ALL_ATTRIBUTES, paged_size=self.paged_size, generator=False)
        data = self.parse_records(self.connection.entries)
        self.update_sidlt(data)
        return data

    def query_domains(self):
        self.connection.extend.standard.paged_search(self.root, '(objectClass=domain)', controls=self.controls, attributes=ldap3.ALL_ATTRIBUTES, paged_size=self.paged_size, generator=False)
        data = self.parse_records(self.connection.entries)
        self.domainLT = {a['objectSid']: '.'.join([b.split('=')[1].upper() for b in a['distinguishedName'].split(',')]) for a in data}
        self.domainLTNB = {a['objectSid']: a['name'].upper() for a in data}
        return data

    def query_gpos(self):
        self.connection.extend.standard.paged_search(self.root, '(objectClass=groupPolicyContainer)', controls=self.controls, attributes=ldap3.ALL_ATTRIBUTES, paged_size=self.paged_size, generator=False) # domainPolicy
        return self.parse_records(self.connection.entries)

    def query_groups(self):
        self.connection.extend.standard.paged_search(self.root, '(objectClass=group)', controls=self.controls, attributes=ldap3.ALL_ATTRIBUTES, paged_size=self.paged_size, generator=False)
        data = self.parse_records(self.connection.entries)
        self.update_sidlt(data)
        return data

    def query_ous(self):
        self.connection.extend.standard.paged_search(self.root, '(objectClass=organizationalUnit)', controls=self.controls, attributes=ldap3.ALL_ATTRIBUTES, paged_size=self.paged_size, generator=False)
        return self.parse_records(self.connection.entries)
    
    def hasFlag(self, flag, value):
        return True if flag & value == flag else False


    def query_trusted_domains(self):
        self.connection.extend.standard.paged_search(self.root, '(objectClass=trustedDomain)', controls=self.controls, attributes=ldap3.ALL_ATTRIBUTES, paged_size=self.paged_size, generator=False)
        data = self.parse_records(self.connection.entries)
        for index in range(0, len(data)):            
            if 'trustAttributesFlags' in data[index]:
                fp = lambda x : x in data[index]['trustAttributesFlags']
                data[index]['sidFiltering'] = True if not fp('WITHIN_FOREST') else fp('QUARANTINED_DOMAIN')
                data[index]['transitive'] = True if not (fp('TREAT_AS_EXTERNAL') or fp('CROSS_ORGANIZATION')) else False

        return data


    def query_users(self):
        self.connection.extend.standard.paged_search(self.root, '(&(objectCategory=person)(objectClass=user))', controls=self.controls, attributes=ldap3.ALL_ATTRIBUTES, paged_size=self.paged_size, generator=False)
        data = self.parse_records(self.connection.entries)
        self.update_sidlt(data)
        return data
        
    def query_info(self):
        '''This one runs on anonymous binds'''
        info = self.server.info.__dict__
        del(info['raw'])
        info['other'] = dict(info['other'])
        return info

    def get_valid_methods(self):
        return [a.split('_', 1)[1] for a in self.__dir__() if a.startswith('query_')]


    def query(self, methods=None):
        out = {}
        valid_methods = self.get_valid_methods()
        if not methods:
            for method in valid_methods:
                out[method] = getattr(self, 'query_{}'.format(method))()
        else:
            for method in methods:
                if method not in valid_methods:
                    raise Exception('Invalid query of {} supplied. Valid methods are: '.format(method, ', '.join(valid_methods)))
                out[method] = getattr(self, 'query_{}'.format(method))()

        if self.post_process_data:
            return self.jsonify(self.post_process(out))
        else:
            return self.jsonify(out)


    def anaylse(self, data, principals=['AUTHENTICATED_USER', 'World']):

        keys = [a for a in data.keys() if a != 'info']
        out = {}
        for key in keys:
            temp = {}
            temp['unresolvedDacls'] = {a['distinguishedName'] : [c for c in a['nTSecurityDescriptor']['Dacls'] if 'ResolvedSidName' not in c ] for a in data[key] 
                                                                 if 'nTSecurityDescriptor' in a for b in a['nTSecurityDescriptor']['Dacls'] if 'ResolvedSidName' not in b}

            temp['unresolvedOwners'] = [{'name' : a['distinguishedName'], 'owner' : a['nTSecurityDescriptor']['OwnerSid']} for a in data[key] 
                                        if 'nTSecurityDescriptor' in a and 'OwnerName' not in a['nTSecurityDescriptor']]

            temp['foreignDacls'] = {a['distinguishedName'] : [c for c in a['nTSecurityDescriptor']['Dacls'] if c['Foreign'] ] for a in data[key] 
                                                              if 'nTSecurityDescriptor' in a for b in a['nTSecurityDescriptor']['Dacls'] if b['Foreign']}

            temp['principalDacls'] = {a['distinguishedName'] : [c for c in a['nTSecurityDescriptor']['Dacls'] if 'ResolvedSidName' in c and c['ResolvedSidName']
                                                                in principals and 'ACCESS_ALLOWED' in c['Type'] ] for a in data[key] if 'nTSecurityDescriptor' in a for b in a['nTSecurityDescriptor']['Dacls']
                                                                if 'ResolvedSidName' in b and b['ResolvedSidName'] in principals}
            
            temp['principalOwners'] = [{'name' : a['distinguishedName'], 'owner' : a['nTSecurityDescriptor']['OwnerName']} for a in data[key] 
                                       if 'nTSecurityDescriptor' in a and 'OwnerName' in a['nTSecurityDescriptor'] and a['nTSecurityDescriptor']['OwnerName'] in principals ]

            temp['groupManagedServiceAccount'] = [a['distinguishedName'] for a in data[key] if 'msDS-ManagedPasswordId' in a]
            temp['unconstrainedDelegation'] = [a['distinguishedName'] for a in data[key] if 'userAccountControlFlags' in a and 'TRUSTED_FOR_DELEGATION' in a['userAccountControlFlags']]
            temp['constrainedDelegation'] = [{'name': a['distinguishedName'], 'allowedToDelegate': a['msDS-AllowedToDelegateTo']} for a in data[key] 
                                             if 'userAccountControlFlags' in a and 'TRUSTED_TO_AUTH_FOR_DELEGATION' in a['userAccountControlFlags']]
            temp['passwordNotRequired'] = [a['distinguishedName'] for a in data[key] if 'userAccountControlFlags' in a and 'PASSWD_NOTREQD' in a['userAccountControlFlags']]
            temp['asRepRoastable'] = [a['distinguishedName'] for a in data[key] if 'userAccountControlFlags' in a and 'DONT_REQ_PREAUTH' in a['userAccountControlFlags']]
            if key != 'computers':
                temp['kerberoastable'] = [a['distinguishedName'] for a in data[key] if 'servicePrincipalName' in a and a['name'] != 'krbtgt']
            
            out[key] = {}
            for tkey in temp:
                if temp[tkey]:
                    out[key][tkey] = temp[tkey]

        return out



    def post_process(self, data):
        # run this to populate domain lookup table if not already run
        if not 'domains' in data:
            self.query_domains()

        for key in [a for a in data.keys() if a != 'info']:
            for index in range(0, len(data[key])):
                for sd in ['nTSecurityDescriptor', 'msDS-GroupMSAMembership']:
                    if sd in data[key][index]:
                        data[key][index][sd] = self.parseSecurityDescriptor(data[key][index][sd])

                if 'domains' not in key:
                    if 'objectSid' in data[key][index]:
                        domainsid = self.get_domain_sid(data[key][index]['objectSid'])
                        if domainsid in self.domainLT:
                            data[key][index]['domain'] = self.domainLT[domainsid]
                        if domainsid in self.domainLTNB:
                            data[key][index]['domainShort'] = self.domainLTNB[domainsid]
                for field in ['securityIdentifier', 'sIDHistory']:
                    if field in data[key][index]:
                        data[key][index][field] = LDAP_SID(data[key][index][field]).formatCanonical()
        return data
                




def check_ipython():
    """Returns True if script is running in interactive iPython shell"""
    try:
        get_ipython()
        return True
    except NameError:
        return False

class MyParser(argparse.ArgumentParser):
    """
    Custom argument parser
    """
    def error(self, message):
        sys.stderr.write('error: %s\n' % message)
        self.print_help()
        sys.exit(2)


def command_line():
    parser = MyParser()
    input_arg_group = parser.add_argument_group('Input')
    input_arg_group.add_argument('-d', '--domaincontroller', type=str, required=True, help='Domain controller address')
    input_arg_group.add_argument('-u', '--username', type=str, default = '', help='Username, use DOMAIN\\username format for NTLM')
    input_arg_group.add_argument('-p', '--password', type=str,  default = '', help='Password, hashes also accepted')
    input_arg_group.add_argument('-m', '--methods', type=str, default='', help='Comma seperated list of collection methods to use')
    output_arg_group = parser.add_argument_group('Output')
    output_arg_group.add_argument('-o', '--output', type=str,  help='Output filename')

    args = parser.parse_args()

    outputfile = args.output if args.output else '{}_AD_Dump.json'.format(args.domaincontroller)

    dumper = AdDumper(args.domaincontroller, username=args.username, password=args.password)
    valid_methods = dumper.get_valid_methods()

    if args.methods:
        requested_methods = [a.strip() for a in args.methods.split(',')]    
        invalid_methods = [a for a in requested_methods if a not in valid_methods]
        if invalid_methods:
            print('Invalid methods were requested! The invalid methods requested were: {}'.format(', '.join(invalid_methods)))
            print('Valid methods are: {}'.format(', '.join(valid_methods)))
            sys.exit(1)
    else:
        requested_methods = valid_methods

    
    dumper.connect()
    data = dumper.query(methods=requested_methods)
    open(outputfile, 'w').write(json.dumps(data, indent=4))

            
if __name__ == "__main__":
    # execute only if run as a script, helpful if script needs to be debugged
    
    if not check_ipython():
        command_line()

