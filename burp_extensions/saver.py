# burp extension to save page response content from the site map via a right click

#burp imports
from burp import IBurpExtender
from burp import IContextMenuFactory

#Java imports
from javax.swing import JMenuItem
from java.util import List,ArrayList
from java.net import URL

#python imports
import threading
import os
from binascii import hexlify

# basedir in which to save responses
baseDir = '/tmp/'
siteMapRetrieve = False # try and rget response data from site map if its not in selected message


class BurpExtender(IBurpExtender,IContextMenuFactory):
    def registerExtenderCallbacks(self,callbacks):
        self.callbacks = callbacks
        self.helpers = callbacks.getHelpers()
        self.callbacks.setExtensionName("Item response saver")
        self.callbacks.registerContextMenuFactory(self)
        self._createIfNotExist(baseDir)
        return

    def createMenuItems(self, IContextMenuInvocation):
        self.selectedMessages = IContextMenuInvocation.getSelectedMessages()
        menuItemList = ArrayList()
        menuItemList.add(JMenuItem("Save responses", actionPerformed = self.onClick))
        return menuItemList

    def _createIfNotExist(self, dir):
        if not os.path.isdir(dir):
            os.mkdir(dir)


    def download(self, messages):
        print 'About to save {} requests to disk...'.format(len(messages))
        filenames = {}
        for message in messages:
            srv_a = self.helpers.analyzeRequest(message)
            this_url = srv_a.getUrl().toString().split(":")[0] + ":" + srv_a.getUrl().toString().split(":")[1] + "/" + srv_a.getUrl().toString().split(":")[2].split("/",1)[1]
            responseInMessage = False
            if 'getResponse' in dir(message):
                rd = message.getResponse()
                if rd:
                    ar = self.helpers.analyzeResponse(rd)
                    bo = ar.getBodyOffset()
                    response = self.helpers.bytesToString(rd)[bo:]
                    
                if len(response) > 2:
                    responseInMessage = True
                else:
                    print 'Response content for {} could not be retrieved from selected message'.format(this_url)


            if siteMapRetrieve and not responseInMessage: # response not in message, try and retrieve from site map
                sm = self.callbacks.getSiteMap(this_url)
                for sme in sm:
                    srv_b = self.helpers.analyzeRequest(sme)
                    entry_url = srv_b.getUrl().toString().split(":")[0] + ":" + srv_b.getUrl().toString().split(":")[1] + "/" + srv_b.getUrl().toString().split(":")[2].split("/",1)[1]
                    if this_url == entry_url:
                        
                        rd = sme.getResponse()
                        if rd:
                            ar = self.helpers.analyzeResponse(rd)
                            bo = ar.getBodyOffset()
                            response = self.helpers.bytesToString(rd)[bo:]
                            
                            if len(response) > 2:
                                break

            bits = [a for a in ("/" + srv_a.getUrl().toString().split(":")[2].split("/",1)[1].split('?')[0]).split('/') if a]
            fn = baseDir + '/'.join(bits)
            od = baseDir
            for di in bits[:-1]:
                od = os.path.join(od, di)
                self._createIfNotExist(od)
            if fn in filenames:
                filenames[fn] += 1
                fn = '{}_{}'.format(fn, str(filenames[fn]-1))
            else:
                filenames[fn] = 0
            open(fn, 'wb').write(response)

            
        print 'Saved {} requests to disk!'.format(len(messages))


    def onClick(self, event):
        requests = self.selectedMessages

        t = threading.Thread(target=self.download,args=[requests])
        t.daemon = True
        t.start()


