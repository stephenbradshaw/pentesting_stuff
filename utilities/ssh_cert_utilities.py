from pyasn1.type import univ
from pyasn1.codec.der import encoder as der_encoder, decoder as der_decoder
from OpenSSL import crypto
import sys
import struct
import base64


# modifed from the below and updated to support python 2 and 3
#https://gist.github.com/thwarted/1024558
def ssh_pub_to_pem(keydata):

    if sys.version_info.major == 2:
        bc = lambda x: ord(x)
    else:
        bc = lambda x: x

    parts = []
    while keydata:
    # read the length of the data
        dlen = struct.unpack('>I', keydata[:4])[0]

        # read in <length> bytes
        data, keydata = keydata[4:dlen+4], keydata[4+dlen:]

        parts.append(data)

    numberfy = lambda x : sum([a[0] << a[1] for a in zip([bc(a) for a in x], [a*8 for a in range(0, len(x))[::-1]] )])

    # get the numeric value of the bytes in big endian order
    e_val = numberfy(parts[1])
    n_val = numberfy(parts[2])

    bitstring = univ.Sequence()
    bitstring.setComponentByPosition(0, univ.Integer(n_val))
    bitstring.setComponentByPosition(1, univ.Integer(e_val))

    bitstring1 = der_encoder.encode(bitstring)

    # turn into a big binary string
    bitstring2 = ''.join([format(bc(x), '08b') for x in bitstring1])


    bitstring3 = univ.BitString("'%s'B" % bitstring2)

    pubkeyid = univ.Sequence()
    pubkeyid.setComponentByPosition(0, univ.ObjectIdentifier('1.2.840.113549.1.1.1')) # == OID for rsaEncryption
    pubkeyid.setComponentByPosition(1, univ.Null(''))

    pubkey_seq = univ.Sequence()
    pubkey_seq.setComponentByPosition(0, pubkeyid)
    pubkey_seq.setComponentByPosition(1, bitstring3)


    #out = "-----BEGIN PUBLIC KEY-----\n"
        
    #base64.MAXBINSIZE = (64//4)*3 # this actually doesn't matter, but it helped with comparing to openssl's output
    #out += base64.encodestring(der_encoder.encode(pubkey_seq)) + '\n'
    #out += '-----END PUBLIC KEY-----\n'
    return base64.b64encode(der_encoder.encode(pubkey_seq))



def match_ssh_keypair(id_rsa_priv_pem, id_rsa_pub_ssh):
    '''Return True if provided private key in PEM format and public key in ssh-rsa format match'''
    if not isinstance(id_rsa_pub_ssh, str) or not id_rsa_pub_ssh.startswith('ssh-rsa '):
        return 'Provide public key in ssh public key string format'
    if not isinstance(id_rsa_priv_pem, str) or not len([a for a in id_rsa_priv_pem.split('\n') if 'PRIVATE KEY' in a]) == 2:
        return 'Provide private key in RSA PEM format'

    private = crypto.load_privatekey(crypto.FILETYPE_PEM, id_rsa_priv_pem)
    public_base = base64.b64decode(id_rsa_pub_ssh.split(' ')[1])

    return ''.join([a for a in crypto.dump_publickey(crypto.FILETYPE_PEM, private).decode('utf-8').split('\n') if a and '--' not in a]) == ssh_pub_to_pem(public_base).decode('UTF8')

