from pyasn1.type import univ
from pyasn1.codec.der import encoder as der_encoder, decoder as der_decoder
from OpenSSL import crypto
import sys
import struct
import base64


# modifed from the below and updated to support python 2 and 3
#https://gist.github.com/thwarted/1024558
def ssh_pub_to_pem(key):

    keydata = base64.b64decode(key.split(' ')[1])

    if sys.version_info.major == 2:
        bc = lambda x: ord(x)
    else:
        bc = lambda x: x

    parts = []
    while keydata:
    # read the length of the data
        dlen = struct.unpack('>I', keydata[:4])[0]

        # read in <length> bytes
        data, keydata = keydata[4:dlen+4], keydata[4+dlen:]

        parts.append(data)

    numberfy = lambda x : sum([a[0] << a[1] for a in zip([bc(a) for a in x], [a*8 for a in range(0, len(x))[::-1]] )])

    # get the numeric value of the bytes in big endian order
    e_val = numberfy(parts[1])
    n_val = numberfy(parts[2])

    bitstring = univ.Sequence()
    bitstring.setComponentByPosition(0, univ.Integer(n_val))
    bitstring.setComponentByPosition(1, univ.Integer(e_val))

    bitstring1 = der_encoder.encode(bitstring)

    # turn into a big binary string
    bitstring2 = ''.join([format(bc(x), '08b') for x in bitstring1])


    bitstring3 = univ.BitString("'%s'B" % bitstring2)

    pubkeyid = univ.Sequence()
    pubkeyid.setComponentByPosition(0, univ.ObjectIdentifier('1.2.840.113549.1.1.1')) # == OID for rsaEncryption
    pubkeyid.setComponentByPosition(1, univ.Null(''))

    pubkey_seq = univ.Sequence()
    pubkey_seq.setComponentByPosition(0, pubkeyid)
    pubkey_seq.setComponentByPosition(1, bitstring3)

    encoded = base64.b64encode(der_encoder.encode(pubkey_seq)).decode('utf8')
    return "-----BEGIN PUBLIC KEY-----\n" + '\n'.join([encoded[a:a+64] for a in range(0, len(encoded), 64)]) + '\n-----END PUBLIC KEY-----\n'



def match_ssh_keypair(id_rsa_priv_pem, id_rsa_pub_ssh):
    '''Return True if provided private key in PEM format and public key in ssh-rsa format match'''
    if not isinstance(id_rsa_pub_ssh, str) or not id_rsa_pub_ssh.startswith('ssh-rsa '):
        return 'Provide public key in ssh public key string format'
    if not isinstance(id_rsa_priv_pem, str) or not len([a for a in id_rsa_priv_pem.split('\n') if 'PRIVATE KEY' in a]) == 2:
        return 'Provide private key in RSA PEM format'

    private = crypto.load_privatekey(crypto.FILETYPE_PEM, id_rsa_priv_pem)
    #public_base = base64.b64decode(id_rsa_pub_ssh.split(' ')[1])

    return ''.join([a for a in crypto.dump_publickey(crypto.FILETYPE_PEM, private).decode('utf-8').split('\n') if a and '--' not in a]) == ''.join([ a for a in ssh_pub_to_pem(id_rsa_pub_ssh).split('\n') if '--' not in a])



def pem_key_details(key):
    '''Given a key in PEM format, provides details about the key'''
    mk = crypto.load_publickey(crypto.FILETYPE_PEM, key)
    ck = mk.to_cryptography_key()
    return {'bits' : mk.bits(), 'e' : ck.public_numbers().e, 'n' : ck.public_numbers().n, 'type' : {getattr(crypto, a): a.replace('TYPE_', '') for a in dir(crypto) if a.startswith('TYPE_')}[mk.type()] }
