#/usr/bin/env python3
import socket
from OpenSSL import SSL, crypto
import requests
import OpenSSL
import asn1crypto
import cert_human

methods = [
    'SSLv23_METHOD',
    'SSLv2_METHOD',
    'SSLv3_METHOD',
    'TLSv1_1_METHOD',
    'TLSv1_2_METHOD',
    'TLSv1_METHOD']
 

# openssl s_client -servername <server_name> -showcerts -connect <server_name>:443

class SSLCertChecker():

    def __init__(self, hostname, port, methods=methods, use_sni=True, cafile=None, force_verify=True, debug=False):
        self.hostname = hostname
        self.port = int(port)
        self.certs = []
        self.methods = methods
        self.use_sni = use_sni
        self.cafile = cafile
        if not self.cafile:
            self.cafile = requests.certs.where() #get trusted ca file from requests module if not provided
        self.debug = debug
        self.force_verify = force_verify



    def verify_cb(self, conn, cert, errnum, depth, ok):
        '''Provided as an alternate cert verify routine - not currently used'''
        self.certs.append(cert)
        return 1 # this verifies all certs


    def guess_root_cert(self, cert):
        '''Retrieve probably signing certificate from a trust store based on a match between subject and issuer of provided intermediate cert'''
        issuer = self.get_issuer(cert)
        return [self.pem_to_x509(a) for a in self.get_trust_store_certs() if self.get_subject(a) == issuer]


    def pem_to_x509(self, cert):
        '''Convert PEM certificate to x509'''
        return crypto.load_certificate(crypto.FILETYPE_PEM, cert)


    def get_trust_store_certs(self):
        '''Get list of PEM certs from trust store - assuming newline seperation between PEM certs in file'''
        return '\n'.join([a for a in open(self.cafile).read().split('\n') if not a.startswith('#')]).split('\n\n')


    def get_issuer(self, cert):
        '''Get issuer of cert in x509 or PEM form'''
        if not isinstance(cert, OpenSSL.crypto.X509):
            cert = self.pem_to_x509(cert)
        return asn1crypto.x509.Certificate.load(crypto.dump_certificate(crypto.FILETYPE_ASN1, cert)).issuer.human_friendly


    def get_subject(self, cert):
        '''Get subject of cert in x509 or PEM form'''
        if not isinstance(cert, OpenSSL.crypto.X509):
            cert = self.pem_to_x509(cert)
        return asn1crypto.x509.Certificate.load(crypto.dump_certificate(crypto.FILETYPE_ASN1, cert)).subject.human_friendly


    # this might be overkill but I have seen some suggestions online that a single pass through verify_certificate only does the intermediate chain
    def chain_verify(self, root, chain):
        '''Does a multi step certificate chain verification at each step for the given context'''
        while len(chain) > 1:
            if self.verify_chain(root, chain):
                if self.debug:
                    print('Chain verification, context length {}'.format(len(chain)))
                chain = chain[1:]
            else:
                return False
        return True


    def verify_chain(self, root, chain):
        '''Verify a certificate chain'''
        store = crypto.X509Store()
        for cert in chain[1:]:
            store.add_cert(cert)
        store.add_cert(root)
        store_ctx = crypto.X509StoreContext(store, chain[0])
        return False if store_ctx.verify_certificate() else True


    def get_certs(self):
        '''Connect to service and grab the full certificate chain'''
        self.certs = []
        for method in self.methods:
            # error handling for connection errors
            try:
                ctx = SSL.Context(getattr(SSL, method))

                ctx.load_verify_locations(cafile=self.cafile)
                #ctx.set_verify(SSL.VERIFY_PEER, self.verify_cb) # alternate method of getting certs,
                sock = SSL.Connection(ctx, socket.socket(socket.AF_INET, socket.SOCK_STREAM))
                sock.settimeout(5)
                if self.use_sni:
                    sock.set_tlsext_host_name(self.hostname.encode())
                sock.connect((self.hostname, self.port))
                sock.setblocking(1)
                sock.do_handshake()
                #sock.send('GET / HTTP/1.1\r\nHost: {}'.format(self.hostname).encode()) #also needed for sni????
                self.certs.append(sock.get_peer_certificate()) 
                for cert in sock.get_peer_cert_chain():
                    if cert.get_serial_number() not in [a.get_serial_number() for a in self.certs]:
                        self.certs.append(cert)
                if self.certs:
                    if self.debug:
                        print('Connection successful with method {}'.format(method.replace('_METHOD', '')))
                    break
            except:
                if self.debug:
                    print('Conenction failure with method: {}'.format(method.replace('_METHOD', '')))
                pass

        if not self.certs:
            raise Exception('Could not successfully connect to service and retrieve certificates')

        # get the certs from the trust store that match based on simple string match issuer<->subject
        proot = self.guess_root_cert(self.certs[-1])
        root_cert = None
        # then run a verification routine against the probable matches to find the correct one
        for root in proot:
            if self.chain_verify(root, self.certs):
                self.certs.append(root)
                root_cert = root

        if not root_cert:
            if self.debug:
                print('Matching verified root certificate not found')
            if self.force_verify:
                raise Exception('Could not verify chain to trusted root, you can try a different trust store or turn off force_verify to get the intermediate chain')
        

        return self.certs




def dump_certs(certs, output='str'):
    '''Dumps human readable output in a number of formats from a list of openssl cert objects'''
    valid_outputs = ['str', 'json', 'json_friendly', 'str_exts', 'str_info', 'str_key']
    if not output in valid_outputs:
        return 'Valid output formats are: {}'.format(', '.join(valid_outputs))
    return getattr(cert_human.CertChainStore.from_pem('\n'.join([crypto.dump_certificate(crypto.FILETYPE_PEM,a).decode('utf8') for a in certs])), 'dump_{}'.format(output) )



# use this

# grabs the cert chain from the remote server and matches it with the root cert from local store
#cc = SSLCertChecker('server.name', 443)
#certs = cc.get_certs()

# dumps them all out in a big text based info dump
#print(dump_certs(certs))

# intended for allowing analysis of all the relevant certs
# is this a secure way of specifically verifying the cert chain? not so sure, do more research on this before making that conclusion
# Check this for more: https://stackoverflow.com/questions/30700348/how-to-validate-verify-an-x509-certificate-chain-of-trust-in-python