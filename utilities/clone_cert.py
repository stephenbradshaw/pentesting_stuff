#!/usr/bin/env python

# clones the clonable fields from a cert provided from an input file
# creates a new cert with a new private key

from OpenSSL import crypto
from cryptography.hazmat.primitives import serialization 
import sys

def CopyCert(input_cert_filename, output_cert_base_filename):
    try:
        fd = open(input_cert_filename).read()
    except Exception as ex:
        return 'Error: %s' %(ex)
    x509 = crypto.load_certificate(crypto.FILETYPE_PEM, fd)

    # Creating key
    k = crypto.PKey()
    k.generate_key(crypto.TYPE_RSA, ((x509.get_pubkey()).bits()))
    cert = crypto.X509()

    # Setting cert details from the original certificate
    cert.set_version(x509.get_version())
    cert.set_serial_number(x509.get_serial_number())
    cert.set_subject(x509.get_subject())
    cert.set_issuer(x509.get_issuer())
    cert.set_notBefore(x509.get_notBefore())
    cert.set_notAfter(x509.get_notAfter())
    cert.set_pubkey(k)
    key1 = k.to_cryptography_key()

    # add extensions
    cert.add_extensions([x509.get_extension(a) for a in range(0, x509.get_extension_count())])

    sig = x509.get_signature_algorithm()
    if 'WithRSAEncryption' not in sig:
        raise Exception('Error: RSA not used to sign cert --- what??. Signature algorithm: %s' %(sig))
    cert.sign(k, sig.replace('WithRSAEncryption', ''))

    # Private key in traditional RSA PEM format - for SAML Raider import
    trsa = key1.private_bytes(encoding=serialization.Encoding.PEM, format=serialization.PrivateFormat.TraditionalOpenSSL, encryption_algorithm=serialization.NoEncryption())

    # PFX file format
    pfx = crypto.PKCS12()
    pfx.set_privatekey(k)
    pfx.set_certificate(cert)
    pfxdata = pfx.export()
    pfxdata_pwd = pfx.export(passphrase='password') # for burp


    # Write all the things
    open(output_cert_base_filename + '.cer', 'w').write(crypto.dump_certificate(crypto.FILETYPE_PEM, cert).decode('utf-8'))
    open(output_cert_base_filename + '.key', 'w').write(crypto.dump_privatekey(crypto.FILETYPE_PEM, k).decode('utf-8'))
    open(output_cert_base_filename + '_pub.key', 'w').write(crypto.dump_publickey(crypto.FILETYPE_PEM, k).decode('utf-8'))
    open(output_cert_base_filename + '_cert.der', 'wb').write(crypto.dump_certificate(crypto.FILETYPE_ASN1, cert))
    open(output_cert_base_filename + '_priv.der', 'wb').write(crypto.dump_privatekey(crypto.FILETYPE_ASN1, k))
    open(output_cert_base_filename + '_pub.der', 'w').write(crypto.dump_publickey(crypto.FILETYPE_ASN1, k))
    open(output_cert_base_filename + '_trad_rsa.key', 'w').write(trsa)
    open(output_cert_base_filename + '.pfx', 'wb').write(pfxdata)
    open(output_cert_base_filename + '_password.pfx', 'wb').write(pfxdata_pwd)
    open(output_cert_base_filename + '_socat.cer', 'wb').write(crypto.dump_privatekey(crypto.FILETYPE_PEM, k).decode('utf-8')+crypto.dump_certificate(crypto.FILETYPE_PEM, cert).decode('utf-8'))



#if __name__ == "__main__":
    
