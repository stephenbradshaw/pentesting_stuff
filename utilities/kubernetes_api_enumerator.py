#!/usr/bin/env python
import json 
import queue
import sys
import requests
import argparse
import logging
from datetime import datetime
from logging import Logger


requests.packages.urllib3.disable_warnings()

def check_ipython() -> bool:
    '''Returns True if script is running in interactive iPython shell'''
    try:
        get_ipython()
        return True
    except NameError:
        return False


class MyParser(argparse.ArgumentParser):
    '''Custom argument parser'''
    def error(self, message: str):
        sys.stderr.write('error: %s\n' % message)
        self.print_help()
        sys.exit(2)


def create_logger(loglevel: str, name: str) -> Logger:
    '''Create a custom logger instance'''
    logger = logging.getLogger(name)
    logger.setLevel(loglevel)
    handler = logging.StreamHandler(sys.stderr)
    formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
    handler.setFormatter(formatter)
    logger.addHandler(handler)

    return logger


class APIEnumerator:

    def __init__(self, apiserver, logger=Logger('APIEnumerator'), clientcert=None, clientkey=None, token=None, enumpaths=['/apis', '/api'], apiextract=True):
        self.apiserver = apiserver
        self.logger = logger
        self.session = requests.Session()
        self.session.verify = False
        self.enumpaths = enumpaths
        self.output = {}
        self.queue = queue.SimpleQueue()
        self.apiextract = apiextract
        if clientcert and clientkey:
            self.clientcert = clientcert
            self.clientkey = clientkey
            self.session.cert = (clientcert, clientkey)
        elif token:
            self.token = token 
            self.session.headers = {'Authorization': 'Bearer {}'.format(token)}
        else:
            self.logger.info('No authentication')
            raise Exception('No authentication method configured')
        

    def _response_parser(self, response, parent):
        if response.get('kind') == 'APIGroupList':
            for group in response['groups']:
                for version in group['versions']:
                    self.queue.put('{}/{}'.format(parent, version['groupVersion']).replace('//', '/'))
        elif response.get('kind') == 'APIResourceList':
            for resource in response['resources']:
                self.queue.put('{}/{}'.format(parent, resource['name']).replace('//', '/'))
        elif response.get('kind') == 'APIVersions':
            for version in response['versions']:
                self.queue.put('{}/{}'.format(parent, version).replace('//', '/'))


    def _try_openapi_eum(self):
        r = self.session.get('https://{}/openapi/v2'.format(self.apiserver))
        if r.status_code == 200 and r.headers.get('Content-Type') == 'application/json' and self.apiextract:
            apidef = json.loads(r.content)
            if 'paths' in apidef:
                self.logger.info('Path information extracted from API def')
                for key in apidef['paths']:
                    # remove paths that require parameters ({value}) and ones that will never finish (/watch/)
                    if not '{' in key and not '/watch/' in key: 
                        self.queue.put(key)
        else:
            for path in self.enumpaths:
                self.queue.put(path)


    def enum(self):
        self._try_openapi_eum()
        while not self.queue.empty():
            path = self.queue.get()
            self.logger.info('{}{}'.format(self.apiserver, path))
            r = self.session.get('https://{}{}'.format(self.apiserver, path))
            if r.headers.get('Content-Type') == 'application/json':
                self.output[path] = json.loads(r.content)
                if r.status_code == 200:
                    self._response_parser(json.loads(r.content), path)


def command_line():
    parser = MyParser()
    input_arg_group = parser.add_argument_group('General')
    input_arg_group.add_argument('-server', type=str, required=True, help='Kubernetes API Server domain name. Include port if not 443')
    input_arg_group.add_argument('-noapiextract', action='store_false', help='Disable extraction of paths from openapiv2 endpoint')

    output_arg_group = parser.add_argument_group('Output')
    output_arg_group.add_argument('-output', type=str, default=None, help='Output filename')
    output_arg_group.add_argument('-loglevel', choices=['DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL'], default='WARNING', help='Set logging level')

    auth_arg_group = parser.add_argument_group('Authentication')
    mgroup_schema = auth_arg_group.add_mutually_exclusive_group()
    mgroup_schema.add_argument('-clientcert', type=str, default=None, help='Client certificate (PEM) file')
    mgroup_schema.add_argument('-token', type=str, default=None, help='Authorization token')
    auth_arg_group.add_argument('-clientkey', type=str, default=None, help='Key file (PRIVATE KEY) associated with client certificate')

    args = parser.parse_args()

    logger = create_logger(args.loglevel, 'Kubernetes API Enumerator')

    if (not args.clientcert) and (not args.token):
        print('Provide at least one authentication method (token or client certificate and key)')
        sys.exit(1)

    if args.clientcert and not args.clientkey:
        print('Provide a key file to use with the client certificate "{}"'.format(args.clientcert))
        sys.exit(1)
    

    outputfile = args.output if args.output else '{}_{}_Kubernetes_API.json'.format(datetime.now().strftime('%Y%m%d%H%M%S'), args.server.replace(':', '_'))

    enumerator = APIEnumerator(args.server, logger=logger, clientcert=args.clientcert, clientkey=args.clientkey, token=args.token, apiextract=args.noapiextract)
    enumerator.enum()
    open(outputfile, 'w').write(json.dumps(enumerator.output, indent=4))
    logger.warning('Wrote output file {}'.format(outputfile))



if __name__ == "__main__":
    # execute only if run as a script, helpful if script needs to be debugged

    if not check_ipython():
        command_line()