"""Basic implementation of an Impacket Kerberos HTTP Request Authentication module for Python Requests"""
# Modified from https://gist.github.com/dirkjanm/299f5389f83e4053c51f33fb8da42f9c

import os
import sys
import datetime
import base64
from pyasn1.type.univ import noValue
from pyasn1.codec.der import decoder, encoder
from impacket.spnego import SPNEGO_NegTokenInit, TypesMech
from impacket.spnego import ASN1_OID, asn1encode, ASN1_AID
from impacket.spnego import SPNEGO_NegTokenInit, TypesMech, ASN1_OID, asn1encode, ASN1_AID
from impacket.krb5.gssapi import KRB5_AP_REQ
from impacket.krb5.asn1 import AP_REQ, Authenticator, TGS_REP, seq_set
from impacket.krb5.types import Principal, KerberosTime, Ticket
from impacket.krb5 import constants
from impacket.krb5.ccache import CCache
from struct import pack
from requests.auth import AuthBase
import logging
from logging import Logger 


def create_logger(loglevel: str, name: str) -> Logger:
    logger = logging.getLogger(name)
    logger.setLevel(loglevel)
    handler = logging.StreamHandler(sys.stderr)
    formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
    handler.setFormatter(formatter)
    logger.addHandler(handler)

    return logger



# Kerberos Authenticator for Python requests using ST in ccache format as created per:
# getST.py -spn HTTP/site.example.com -dc-ip 1.2.3.4 EXAMPLE/username

# Does preemptive authentication (e.g. will not wait for Negotiate 401 response before sending auth header)

# Use with requests like so
# from basic_kerberos_auth import HTTPBasicKerberosAuth
# kerberos_auth = HTTPBasicKerberosAuth()
# r = requests.get(url, auth=kerberos_auth)



class HTTPBasicKerberosAuth(AuthBase):
    """Basic Requests HTTP Kerberos authentication module"""

    def __init__(self, ccache=None, serverPrincipal=None, loglevel=None):
        self.ccache_file = ccache if ccache else os.getenv('KRB5CCNAME')
        if ccache:
            self.ccache = CCache.loadFile(ccache)
        else:
            if not os.getenv('KRB5CCNAME'):
                raise Exception('No credential file specified and no value in KRB5CCNAME environment variable')
            self.ccache = CCache.loadFile(os.getenv('KRB5CCNAME'))

        if not loglevel:
            loglevel = logging.root.level

        self.logger = create_logger(loglevel, 'HTTPBasicKerberosAuth')

        self.logger.debug('Ccache file: {}'.format(self.ccache_file))
        self.serverPrincipal = serverPrincipal


    def __call__(self, request):
        request.headers['Authorization'] = 'Negotiate {}'.format(base64.b64encode(self.auth(request)).decode())
        return request


    # Modified from
    # https://gist.github.com/dirkjanm/299f5389f83e4053c51f33fb8da42f9c
    def auth(self, request):

        get_cred_host = lambda x: x.getServerPrincipal().decode().split('@')[0].split('/')[1]
        match = request.url.split('/')[2]

        creds = self.ccache.credentials
        if len(creds) < 1:
            raise Exception('No credentials in provided ccache file {}'.format(self.ccache_file))
        
        self.logger.debug('Ccache file has {} credentials'.format(len(creds)))

        if self.serverPrincipal:
            match = self.serverPrincipal

        matching_creds = [a for a in creds if get_cred_host(a) == match]

        if len(matching_creds) < 1:
            raise Exception('No credential found in cache matching target host {}'.format(match))
        
        matched_cred = matching_creds[0]
        credServicePrincipal = matched_cred.getServerPrincipal().decode()
            
    
        endtime = matched_cred.header.fields['time']['endtime']

        if endtime < datetime.datetime.now(datetime.timezone.utc).timestamp():
            raise Exception('Credential has expired')
        

        TGS = matched_cred.toTGS()
        tgs1, cipher, sessionKey = TGS['KDC_REP'], TGS['cipher'], TGS['sessionKey']

        blob = SPNEGO_NegTokenInit()

        # Kerberos v5 mech
        blob['MechTypes'] = [TypesMech['MS KRB5 - Microsoft Kerberos 5']]

        # Let's extract the ticket from the TGS
        tgs = decoder.decode(tgs1, asn1Spec = TGS_REP())[0]

        domain = str(tgs.getComponentByName('crealm'))
        user = [a for a in str(tgs.getComponentByName('cname')).split('\n') if a][-1].strip()
      
        self.logger.debug('Credential: Server principal:{}; Domain: {}; User: {}; Expiry: {}'.format(credServicePrincipal, domain, user, str(datetime.datetime.fromtimestamp(endtime))))

        ticket = Ticket()
        ticket.from_asn1(tgs['ticket'])

        # Now let's build the AP_REQ
        apReq = AP_REQ()
        apReq['pvno'] = 5
        apReq['msg-type'] = int(constants.ApplicationTagNumbers.AP_REQ.value)

        opts = list()
        apReq['ap-options'] = constants.encodeFlags(opts)
        seq_set(apReq,'ticket', ticket.to_asn1)

        authenticator = Authenticator()
        authenticator['authenticator-vno'] = 5
        authenticator['crealm'] = domain
        
        userName = Principal(user, type=constants.PrincipalNameType.NT_PRINCIPAL.value)
        seq_set(authenticator, 'cname', userName.components_to_asn1)
        now = datetime.datetime.utcnow()

        authenticator['cusec'] = now.microsecond
        authenticator['ctime'] = KerberosTime.to_asn1(now)

        encodedAuthenticator = encoder.encode(authenticator)

        # Key Usage 11
        # AP-REQ Authenticator (includes application authenticator
        # subkey), encrypted with the application session key
        # (Section 5.5.1)
        encryptedEncodedAuthenticator = cipher.encrypt(sessionKey, 11, encodedAuthenticator, None)

        apReq['authenticator'] = noValue
        apReq['authenticator']['etype'] = cipher.enctype
        apReq['authenticator']['cipher'] = encryptedEncodedAuthenticator

        blob['MechToken'] = pack('B', ASN1_AID) + asn1encode(pack('B', ASN1_OID) + asn1encode(
            TypesMech['KRB5 - Kerberos 5']) + KRB5_AP_REQ + encoder.encode(apReq))
        return blob.getData()
