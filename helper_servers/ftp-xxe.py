#!/usr/bin/env python

import time, socket
from optparse import OptionParser
from SocketServer import BaseRequestHandler, ThreadingTCPServer
from sys import stdout

class FTPHandler(BaseRequestHandler):
    """Handler for FTP sessions."""

    def debug(self, message):
        """Show log message."""
        if self.server.debug:
            print '***', message

    def respond(self, code, explanation):
        """Send a response to the client."""
        self.request.send('%d %s\r\n' % (code, explanation))

    def process_request(self):
        """Parse input into a command and an argument."""
        data = self.recvall()
        parts = data.strip().split(' ',1)
        return parts.pop(0), parts, data.strip()

    def log_auth(self, user, password):
        """Write data to logfile."""

        line = ' '.join((now, client, user, password))
        self.server.logfile.write(line + '\n')
        self.server.logfile.flush()

    def save_to_file(self, data):
        client = '%s:%d' % self.client_address
        filename = client + '-' + str(int(time.time()))
        with open(filename, 'w') as f:
            f.write(data)

    def recvall(self, timeout=''):
        #setup to use non-blocking sockets
        #if no data arrives it assumes transaction is done
        #recv() returns a string
        self.request.setblocking(0)
        total_data=[]
	data=''
        begin=time.time()
        if not timeout:
            timeout=1
        while 1:
            #if you got some data, then break after wait sec
            if total_data and time.time()-begin>timeout:
                break
            #if you got no data at all, wait a little longer
            elif time.time()-begin>timeout*2:
                break
            wait=0
            try:
                data=self.request.recv(64)
                if data:
                    total_data.append(data)
                    begin=time.time()
                    data='';wait=0
                else:
                    time.sleep(0.001)
            except:
                pass
            #When a recv returns 0 bytes, other side has closed
        result=''.join(total_data)
        return result

    def handle(self):
        """Handle incoming data."""
        self.debug('Connection from %s:%d.' % self.client_address)
        self.respond(220, 'Welcome')
        self.recvdata = ''

        while True:
            cmd, args, data = self.process_request()
            arg = (args and args[0] or '')
            if cmd == 'USER':
                self.debug(data.strip())
                self.respond(331, 'Please specify the password.')
            # signals an attempt to change to passive mode, but by this time we probably already have our data and want to terminate
            elif cmd == 'EPSV':
                self.debug(data.strip())
                self.respond(230, 'Proceed')
                self.debug('R: 230, Proceed')
            elif cmd == 'CWD':
                #self.debug(data.strip())
                if self.server.verbose or self.debug:
                    stdout.write('/' + arg)
                self.recvdata += '/' + arg
                self.respond(230, 'Proceed')
            elif cmd == 'RETR':
                self.debug(data.strip())
                if self.server.verbose or self.debug:
                    stdout.write('/' + arg)
                self.recvdata += '/' + arg
                self.respond(530, 'Go away')
                break
            else:
                self.debug(data.strip())
                self.respond(230, 'Proceed')
                self.debug('R: 230, Proceed')

        self.request.close()
        if self.server.verbose or self.debug:
            print "\n"
        if self.server.save_to_file:
            self.save_to_file(self.recvdata[1:]) #remove leading added /
        self.debug('Connection with %s:%d closed.' % self.client_address)


class FTPServer(ThreadingTCPServer):

    def __init__(self, host='', port=21, debug=False, save_to_file=False,
            verbose=True):
        ThreadingTCPServer.__init__(self, (host, port), FTPHandler)
        self.debug = debug
        self.verbose = verbose
        self.save_to_file = save_to_file

    def server_close(self):
        ThreadingTCPServer.server_close(self)



if __name__ == '__main__':
    parser = OptionParser(usage='%prog [options] <port>')
    parser.add_option('-d', '--debug', dest='debug', action='store_true',
        help='show debugging messages')
    parser.add_option('-s', '--save', dest='save_to_file', action='store_true',
        help='write collected data to generated logfiles')
    opts, args = parser.parse_args()

    # Parse arguments.
    if len(args) != 1:
        parser.print_help()
        parser.exit()
    try:
        port = int(args[0])
    except ValueError:
        parser.print_help()
        parser.exit()

    # Serve.
    server = FTPServer(port=port, **opts.__dict__)
    try:
        server.serve_forever()
    except KeyboardInterrupt:
        print 'Ctrl-C pressed, exiting...'
    server.server_close()

