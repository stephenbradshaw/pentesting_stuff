#!/usr/bin/env python3

import sys
import os
import argparse
from http.server import SimpleHTTPRequestHandler
import socketserver
import logging
import ssl


class MyParser(argparse.ArgumentParser):
    def error(self, message):
        sys.stderr.write('error: %s\n' % message)
        self.print_help()
        sys.exit(2)


class LoggingHTTPRequestHandler(SimpleHTTPRequestHandler):

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
    
    def _set_response(self):
        self.send_response(200)
        self.send_header('Content-type', 'text/html')
        self.end_headers()

    def do_GET(self):
        logging.info("GET request,\nPath: %s\nHeaders:\n%s\n", str(self.path), str(self.headers))
        super().do_GET()

    def do_OPTIONS(self):
        logging.info("OPTIONS request,\nPath: %s\nHeaders:\n%s\n", str(self.path), str(self.headers))
        super().do_GET()


    def do_POST(self):
        content_length = int(self.headers['Content-Length'])
        post_data = self.rfile.read(content_length)
        logging.info("POST request,\nPath: %s\nHeaders:\n%s\n\nBody:\n%s\n",
                str(self.path), str(self.headers), post_data.decode('utf-8'))

        self._set_response()
        self.wfile.write("POST request for {}".format(self.path).encode('utf-8'))

    def end_headers(self):
        if 'origin' in self.headers and (not getattr(self, 'disable_cors_headers', False)):
            a_headers = ['content-type', 'x-requested-with']
            a_headers += [a.rstrip().lstrip() for a in self.headers.get('Access-Control-Request-Headers', '').split(',') if a]
            a_methods = ['POST', 'GET', 'OPTIONS', 'DELETE']
            a_methods += [a.rstrip().lstrip() for a in self.headers.get('Access-Control-Request-Methods', '').split(',') if a]
            origin = self.headers.get('origin')
            response_headers = {
                'Access-Control-Allow-Origin' :  origin if origin != 'null' else '*',
                'Access-Control-Allow-Methods': ', '.join(set([a for a in a_methods if a])),
                'Access-Control-Allow-Headers' : ', '.join(set([a for a in a_headers if a])),
                'Access-Control-Allow-Credentials': 'true'
            }
            for key in response_headers:
                self.send_header(key, response_headers[key])
        super().end_headers()


def create_custom_handler(directory: str, disable_cors: bool):

    class PathedLoggingHTTPRequestHandler(LoggingHTTPRequestHandler):
        def __init__(self, *args, **kwargs):
            self.disable_cors_headers = disable_cors
            super().__init__(*args, directory=directory, **kwargs)
    
    return PathedLoggingHTTPRequestHandler



def run(port: int, address: str='', wrap_ssl: bool=False, ssl_keyfile: str=None, ssl_certfile: str=None, directory: str=None, disable_cors=False):
    logging.basicConfig(level=logging.INFO)
    server_address = (address, port)
    directory = directory if directory else os.getcwd()
    #httpd = HTTPServer(server_address, create_custom_handler(directory, disable_cors))
    httpd = socketserver.ForkingTCPServer(server_address, create_custom_handler(directory, disable_cors))

    if wrap_ssl:
        httpd.socket = ssl.wrap_socket (httpd.socket, 
            keyfile=ssl_keyfile, 
            certfile=ssl_certfile, server_side=True)
    
    logging.info('Starting httpd on port {}...\n'.format(str(port)))
    try:
        httpd.serve_forever()
    except KeyboardInterrupt:
        pass
    httpd.server_close()
    logging.info('Stopping httpd...\n')


if __name__ == '__main__':

    parser = MyParser()
    parser.add_argument('-p', '--port', type=int, required=True, help='Port to serve on')
    parser.add_argument('-s', '--ssl', action='store_true', default=False, help='Enable ssl. If set you also need to provide a key and cert file . Default: disabled.')
    parser.add_argument('-k', '--key', type=str,  default=None, help='SSL private key file in pem format')
    parser.add_argument('-c', '--cert', type=str,  default=None, help='SSL certificate file in pem format')
    parser.add_argument('-a', '--address', type=str,  default='', help='Address to bind the server to, defaults to all ')
    parser.add_argument('-d', '--directory', type=str,  default=None, help='Directory to serve files from. pwd is used if not set.')
    parser.add_argument('-o', '--disable_cors', action='store_true',  default=False, help='Disable the addition of permissive CORS headers in responses to requests with Origin header')
    args = parser.parse_args()
    
    if args.ssl:
        if not args.key and args.cert:
            print('If the ssl option is enabled you must also provide both a certificate (-c) and key (-k) file')
            parser.print_help()
            sys.exit(2)

    run(port=args.port, address=args.address, wrap_ssl=args.ssl, ssl_keyfile=args.key, ssl_certfile=args.cert, directory=args.directory, disable_cors=args.disable_cors)
    

    